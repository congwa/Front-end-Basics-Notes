# 常见线程池模型

## 为什么需要线程池

反复创建线程系统开销比较大,而且每个线程的创建和销毁都需要时间,如果任务比较简单,那么有可能导致线程的创建和销毁占用的资源超过执行任务所消耗的资源.

如果当要执行的任务比较多时,每个线程负责一个任务,那么需要创建很多线程去执行任务,过多的线程会占用过多的内存资源等,还会带来上下文切换,同时还会导致系统不稳定.

### 线程池好处

线程池解决了线程生命周期的系统开销问题,线程池中的线程可以反复使用,可以用少量的线程去执行大量的任务,减少了线程创建和销毁的开销,而且线程都是创建好的,来任务就可以执行.

通过设置合适的线程池的线程数,可以避免资源使用不当,线程池可以通过线程数和任务灵活的控制线程数量,任务多的时候可以继续创建线程,任务少的时候只保留核心线程,这样可以避免系统资源浪费和线程过多导致内存溢出.

线程池可以统一管理资源,通过线程书和任务队列,可以统一开始和结束,并设置相关的拒绝策略.

## 线程池的组成

- corePoolSize:核心线程数,常驻线程池的线程数量
- maxPoolSize:线程池最大线程数量,当任务特别多的时候,corePoolSize线程数量无法满足需求的时候,就会继续创建线程,最大不超过maxPoolSize.
- KeepAliveTime+时间单位:空闲线程的存活时间
- ThreadFactory:线程工厂,用来创建线程
- WorkQueue:任务队列,用来存放任务
- Handler:处理被拒绝的策略

![一般线程池流程图](/study/imgs/%E4%B8%80%E8%88%AC%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)‘
![线程池完整流程图](/study/imgs/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

1. 当提交任务后,,线程池首先会检查当前线程数,如果当前线程数小于核心线程数,则新建线程并执行任务.
2. 随着任务不断增加,线程数达到了核心线程数的数量,此时任务依然在增加,那么新来的任务将会放到workQueue等待队列中,等核心线程执行完任务后重新从队列中提取出等待被执行的任务
3. 如果已经达到了核心线程数,且任务队列也满了,则线程池就会继续创建线程来执行任务,如果任务不断提交,线程池会持续创建线程直到达到maximumPoolSize最大线程数,当达到了最大线程数后,任务仍不断提交,那么此时就超过了线程池的最大处理能力,这个时候线程池就会拒绝处理这些任务,处理策略就是handler.
4. corePoolSize和maximumPoolSize：
   从上面的流程中可以看出,线程池初始化时,默认的线程数是0,当有任务提交后,开始创建核心线程去执行任务,当线程数达到核心线程数时且任务队列满了后,开始创建非核心线程执行任务,最大可以达到maximumPoolSize,如果这是任务不提交了,线程开始空闲,那么默认情况下大于corePoolSize的线程在超过设置的KeepAliveTime时间后会被合理的收回,所以默认情况下,线程池中的线程数量处于corePoolSize和maximumPoolSize之间.
5. KeepAliveTime+时间单位：
   默认情况下,当线程池中的数量多于核心线程数时,而此时有没有任务可做,那么线程池就会检测线程的KeepAliveTime,如果超过了规定的时间,则无事可做的线程就会被销毁,以便减少内存的占用和资源消耗,如果后期任务又多了起来,则线程池根据规则重新创建线程,通过这个可伸缩的功能,可以实现对资源的合理使用,我们可以通过setKeepAliveTime设置keepAliveTime时间,还可以通过设置allowCoreThreadTimeOut参数,这个参数默认是false,如果设置成true,则会给核心线程数设置超时等待时间, 如果超过时间了核心线程就会销毁.
6. ThreadFactory：
    ThreadFactory是一个线程工厂,负责生产线程去执行任务,默认的线程工厂,创建的线程会在同一个线程组,并且拥有一样的优先级,且都不是守护线程,我们也可自定义线程工厂,以便给线程自定义名字.
7. workQueue：
    阻塞队列,用来存放任务,我们主要分析一下5种阻塞队列:
        - ArrayBlockingQueue是基于数组的有界阻塞队列,按照FIFO排序,新来的队列会放到队列尾部,有界的数组可以防止资源被耗尽问题,当线程达到了核心线程数,再来任务的时候就放到队列的尾部,当队列满了的时候,则继续创建非核心线程,如果线程数量达到了maxPoolSize,则会执行拒绝策略.
        - LinkedBlockingQueue是基于链表的无界阻塞队列(最大容量是Integer.MAX),按照FIFO排序,当线程池中线程数量达到核心线程数时,继续来了新任务会一直存放到队列中,而不会创建新线程.因此使用此队列时,maxPoolSize是不起做的
        - SynchronousQueue是一个不缓存任务的阻塞队列,当来了新任务的时候,不会缓存到队列中,而是直接被线程执行该任务,如果没有核心线程可用就创建新线程去执行任务,达到了maxPoolSize时,就执行拒绝策略.
        - PriorityBlockingQueue是一个具有优先级的无界阻塞队列,优先级通过参数Comparator实现
        - DelayedWorkQueu队列的特点是内部的任务并不是按照放入的时间排序,而是会按照延迟的时间长短对任务进行排序,内部采用的是“堆”数据结构.而且它也是一个无界队列.
8. handler：
    拒绝策略是当线程池中任务达到了队列最大容量,且线程数量也达到了最大maxPoolSize的时候,如果继续有新任务来了,则执行这个拒绝策略来处理新来的任务,jdk提供4种拒绝策略,它们都实现了RejectedExecutionHandler接口:
        - CallRunsPolicy:该策略下,在调用者线程中直接执行被拒绝任务的run方法,就是谁提交的任务,谁负责执行任务,这样任务不会丢失,而且执行任务比较费时,那么提交任务的线程也会被占用,就可以减缓任务提交速度.
        - AbortPolicy:该策略下,直接抛弃任务,并抛RejectedExecutionException异常.
        - DiscardPolicy:该策略下,直接抛弃任务.
        - DiscardOldestPolicy:该策略下,抛弃最早进入队列中的那个任务,然后尝试把这次拒绝的任务放入队列.
    除此之外，我们还可以通过实现 RejectedExecutionHandler 接口来实现自己的拒绝策略,在接口中我们需要实现rejectedExecution方法,在rejectedExecution方法中,执行例如暂存任务、重新执行等自定义拒绝策略.


## 常见线程池

### 1. FixedThreadPool-固定线程数

这个线程池的核心线程数和最大线程数是一样的,所以可以看作是固定线程数的线程池,特点是当线程达到核心线程数后,如果任务队列满了,也不会创建额外的非核心线程去执行任务,而是执行拒绝策略.

### 2. CachedThreadPool- 缓存线程池

这个线程池叫做缓存线程池,特点是线程数几乎是可以无限增加的(最大值是Integer.MAX_VALUE,基本不会达到),当线程闲置时还可以进行回收,而且它采用的存储任务的队列是SynchronousQueue队列,队列容量是0,实际不存储任务,只负责对任务的中转和传递,所以来一个任务线程池就看是否有空闲的线程,有的话就用空闲的线程去执行任务,否则就创建一个线程去执行,效率比较高.

### 3. ScheduledThreadPool-周期性执行任务

通过这个线程池的名字可以看出,它支持定时或者周期性执行任务,实现这种功能的方法主要有三种:

- schedule,通过延迟指定时间后执行一次任务,代码中设置的是10秒,所以10秒后执行一次任务就结束.
- scheduleAtFixedRate,通过名称我们可以看出,第二种是以固定频率去执行任务,它的第二个参数initialDelay表示第一次延迟时间,第三个参数period表示周期,总体按照上面的代码意思就是,第一次延迟10秒后执行任务,然后,每次延迟10秒执行一次任务.
- scheduleWithFixeddelay这种与第二种方法类似,也是周期执行任务,不同的是对周期的定义,之前的scheduleAtFixedRate是以任务的开始时间为起点开始计时,时间到了就开始执行第二次任务,而不管任务需要多久执行,而scheduleWithFixeddelay是以任务结束的时间作为下一次循环开始的时间起点.

```java
ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
service.schedule(new Task(), 10, TimeUnit.SECONDS);
service.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);
service.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);
```
 

### 4. SingleThreadExecutor-只有一个线程去执行任务

第四种线程池中只有一个线程去执行任务,如果执行任务过程中发生了异常,则线程池会创建一个新线程来执行后续任务,这个线程因为只有一个线程,所以可以保证任务执行的有序性.

### 5. SingleThreadScheduleExecutor- 只有一个线程，只是将核心线程数设置为了1

这个线程池它和ScheduledThreadPool很相似,只不过它的内部也只有一个线程,他只是将核心线程数设置为了1,如果执行期间发生异常,同样会创建一个新线程去执行任务.
### 6. ForkJoinPool - 分解成多个子任务，并行计算

最后一种线程池是ForkJoinPool,这个线程池是来支持将一个任务拆分成多个“小任务”并行计算，这个线程池是在jdk1.7之后加入的,它主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，这里只是对ForkJoinPool做了一个简单的介绍,我们先来介绍一下ForkJoinPool和之前的线程池主要的两个特点。

#### 第一点是fork和join:

ork就是将任务分解成多个子任务，多个子任务互相独立，不受影响，执行的时候可以利用 CPU 的多核优势，并行计算，计算完成后各个子任务在调用join方法进行结果汇总，第一步是拆分也就是 Fork，第二步是汇总也就是 Join，

#### 第二点是内部结构不同

之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列,这个队列是双端队列


ForkJoinPool 线程池内部除了有一个共用的任务队列之外，每个线程还有一个对应的双端队列 deque，这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中(公共任务队列采用数组存放)，如果此时有三个子任务放入线程 t1 的 deque 队列中，对于线程 t1 而言获取任务的成本就降低了，可以直接在自己的任务队列中获取而不必去公共队列中争抢也不会发生阻塞（除了后面会讲到的 steal 情况外），减少了线程间的竞争和切换，是非常高效的。

我们再考虑一种情况，此时线程有多个，而线程 t1 的任务特别繁重，分裂了数十个子任务，但是 t0 此时却无事可做，它自己的 deque 队列为空，这时为了提高效率，t0 就会想办法帮助 t1 执行任务，这就是“work-stealing”的含义。

双端队列 deque 中，线程 t1 获取任务的逻辑是后进先出，也就是LIFO（Last In Frist Out），而线程 t0 在“steal”偷线程 t1 的 deque 中的任务的逻辑是先进先出，也就是FIFO（Fast In Frist Out），如图所示，图中很好的描述了两个线程使用双端队列分别获取任务的情景。你可以看到，使用 “work-stealing” 算法和双端队列很好地平衡了各线程的负载。


ForkJoinPool每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。


## 如何自定义合适的线程池

首先我们要调整线程池中的线程数量以便充分并合理的使用CPU和内存资源,从而最大限度的提高性能.

### CPU密集型任务

如果任务是一些列比较消耗CPU资源的任务,比如加密、解密、压缩、计算等,那么最佳线程数是CPU核心数的1~2倍,过多很导致占用大量CPU资源,这时每个CPU的核心工作基本都是满负荷,设置过多的线程会造成不必要的上下文切换,而导致性能下降,而且在同一台机器上,我们还要考虑到其他会占用较多CPU资源的程序运行,然后做整体平衡.

### 耗时IO任务

例如数据库、文件的读写，网络通信等任务,这种任务的特点是不会消耗很多CPU资源,但是IO操作很费时.这个时候可以设置最大线程数一般会大于CPU核心线程数很多倍,因为IO速度相比于CPU速度比较慢,我们设置较少的线程数,就会浪费CPU资源,如果设置更多的线程数,那么一部分线程正在等待IO的时候,他们此时不需要CPU计算,就能有更多线程去执行IO操作,任务队列中的等待任务就会减少,更合理的利用了资源.

java并发编程实战中有推荐:线程数 = CPU核心数 *(1+平均等待时间/平均工作时间)

### 总结

- 线程的平均工作时间所占比例越高,就需要越少线程.
- 线程的平均等待时间所占比例越高,就需要越多的线程
- 针对不同的程序,进行对应的实际测试就可以获得更合适的选择.

## 如何正确关闭线程池

首先有5种在ThreadPoolExecutor中涉及的关闭线程的方法，我们挨个来分析

- void shutdown()
  - 等待线程池中正在执行的任务和队列中等待的任务执行完毕。这个方法不会立即关闭线程池，而是允许已经提交的任务继续执行
- boolean isShutdown()
  - 检查线程池是否已经开始关闭。如果返回值为 true，表示线程池已经开始关闭但还未彻底关闭，可能仍有任务在执行或队列中等待执行
- boolean isTerminated()
  - 方法判断线程池是否已经彻底关闭。如果返回值为 true，表示线程池已经关闭且所有任务已经执行完毕
- boolean awaitTermination(long timeout,TimeUnit unit)，throws IntereuptedException
  - 等待一段指定的时间，如果在等待时间内线程池已关闭且所有任务都执行完毕，则返回 true；如果等待时间超时或者等待期间被中断，则返回 false。
- List shutdownNow()
  - 如果需要立即关闭线程池并且停止所有任务的执行，可以调用 shutdownNow() 方法。该方法会给所有线程发送中断信号并将等待执行的任务转移到一个列表中返回
  

## 线程池复用原理

线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。

在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。

```java
public void execute(Runnable command) { 
    //如果传入的Runnable的空，就抛出异常
    if (command == null) 
        throw new NullPointerException();
    int c = ctl.get();
    /**
    * 当前线程数是否小于核心线程数，如果小于核心线程数就调用 addWorker() 
    * 方法增加一个 Worker，这里的 Worker 就可以理解为一个线程
    */
    if (workerCountOf(c) < corePoolSize) { 
        if (addWorker(command, true)) 
            return;
        c = ctl.get();
    } 
    if (isRunning(c) && workQueue.offer(command)) { 
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command)) 
            reject(command);
        else if (workerCountOf(recheck) == 0) 
            addWorker(null, false);
    } 
    else if (!addWorker(command, false)) 
        reject(command);
}
```