# qwik 

号称世界上第一个 O(1) 的 JavaScript SSR 框架.

看到这句话不得想到， 这是啥玩意？ 比react的选择性注水好吗？

那就探索一下吧。

嗯。读帖子又发现了一个方案。

Remix 的 [HTTP stale-while-revalidate 缓存指令](https://zhuanlan.zhihu.com/p/64694485).
> 在stale-while-revalidate指定的时间段内读取缓存的话，Chrome DevTools 里除了能看到本身的那个直接读取过期缓存的请求（200），还可以看到异步刷新缓存的请求（304）
> stale-while-revalidate是为了加载速度牺牲了资源的新鲜性（通常就牺牲一次），但有些场景下，可能一次也无法接受，
> 优先让用户看到数据，毕竟有些情况下，新的数据与老的数据也差不多，就像我的微信会话列表，这种体验相比于先给用户一个菊花就要好很多
> swr 给你的资源缓存判了「死缓」，虽然缓存过期了，但还能再撑一下（用过期数据返回），下次请求又是一条好汉（上次请求时已经后台刷新过）
> swr 的其中一种食用方法就是 Service Worker！我们可以通过 sw 来模拟 swr 的行为，毕竟所有的请求都可以路由到 sw 脚本，我们能控制的地方也就有很多了
> 上面说到的，包括标准里设计的，都是需要用户下次请求时才会把 revalidated 的数据返回回来，而 swr 这个库则更进一步，它会帮你自动重新渲染.

## 传统水合过程

1. 每一个事件处理程序中的内容，绝大多数框架中的状态都做为闭包函数保存在内容中。所以需要 hydration 的过程来重新获取状态
2. 其次，在搞清楚了每个事件处理函数的内容后。我们也需要将对应的事件处理函数附加到对应的 DOM 节点上，同时还要确保该监听器的正确事件类型

通俗来说 Hydration 就是在客户端重新执行 JS 去修复应用程序内部的应用程序状态 以及 框架内部状态

- 应用程序状态：html事件中的各个状态事件
- react或者vue这种框架的内部状态，比如虚拟dom对应关系

总结： 其实就是把该准备的准备好，然后把应该对应的关系对应上而已。

### 过程和性能分析

1. Server 端下发的 HTML 静态页面 -- 无交互、有注水标记
2. 下载所有相关 JS 脚本   -- 不可**阻塞**1, 可同步
3. 解析并且执行下载的 JS 脚本。-- 不可阻塞1，不可和1同步。
4. recover state  & bind listeners

1、2、3称为 recovery阶段，RECOVERY 阶段是和 hydartion 的页面的复杂性成正比。

在qwik中认为前三个阶段是没有必要的。  
因为在服务端我们已然渲染过对应的 HTML ，但是为了应用程序的可交互性以及服务端仅保留了静态的 HTML 模版导致不得不在 Client 上继续执行一次 Server 端的逻辑
> 看到这已经大概知道qwik是个什么玩意了。 大胆假设(小心求证)：把每个dom的用户交互的关联的js分包出去，然后在用户交互的部分进行下载。根据语义把用户交互极致的分包？ 如何做到？状态是如何关联的？但是如果是这种方案，可以想象，在react的生态下，注定只是想法最终被吸纳的炮灰。

同一个应用程序，会被发送到客户端两次，一次作为 HTML，另一次作为 JavaScript。
此外，框架必须立即执行 JavaScript 以恢复在服务器上被丢掉的 APP_STATE和FRAMEWORK_STATE。所有这些工作只是为了检索服务器已经拥有但丢弃的东西！！

> 看到这里。 确实都是renderToString 或者 renderToStream的痛点。
> 哎。浏览器渲染进程的主线程就是这么设计的，没办法多并发。 啥时候使用go或者rust重写浏览器，新时代估计来临的。仅仅只是技术猜想，毕竟针对企业，完全没有go或者rust重写的必要性，即便重写了，对市场的竞争力也就那样吧。 生态也是问题。

要使网页具有交互性，必须要做的就是通过下载对应 HTML 页面中的 script 脚本并执行代码从而恢复按钮上的交互逻辑和状态。
为了具有交互性，客户端不得不执行代码实例化组件后重新创建状态。

## Resumability： 更加优雅的 hydartion 替代方案

所以为了消除额外的开销，我们需要思考如何避免重复的 RECOVERY 阶段。同时还要避免上面的第四步，第四步是执行脚本后给现有的 HTML 附加正确的事件处理程序。

qwik 中提出了一个全新的思路来规避 RECOVERY 带来的外开销：

1. 将所有必需的信息序列化为 HTML 的一部分。

    - qwik 将需要的状态以及事件序列化保存在 Server 端下发的 HTML 模版中，需要序列化信息需要包括WHAT（事件处理函数内容）, WHERE（哪些节点需要哪些类型的事件处理函数）, APP_STATE（应用状态）, 和FRAMEWORK_STATE（框架状态）。

  > 携带这么多描述信息，不单纯的html了，首屏的html文件会更大。aot消耗应该也会更大。

1. 依赖于事件冒泡来拦截所有事件的全局事件处理程序。

    - qwik 中事件处理程序是在全局处理的，这样我们就不必在在特定的 DOM 元素上单独注册所有事件。

2. qwki 内部存在一个可以**延迟恢复事件处理程序的工厂函数**。

    - 该工厂函数主要用于处理 WHAT 阶段，也就是用来识别某个事件处理函数中应该存在什么脚本逻辑。
![qwik](https://pic1.zhimg.com/80/v2-8761f9ed68df2d82b586c0f4002e1358_1440w.webp)

**获取完服务端下发的 HTML 页面后所有的交互效果实际上都是一种惰性创建的效果**。 
> qwik是这么认为的

在 HTML 中的每个元素中都已经通过序列化从而在它的标签属性上记录了对应事件处理函数的位置以及脚本内容（自然内容中也包含对应的状态），所以当获得 HTML 页面后其实就可以说此时页面已经加载完毕了而不需要任何实时的 JS 执行。

客户端完全不必和服务端的 HTML 进行水合，相同的渲染内容仅仅是在 Server 端进行一次渲染客户端即可拥有对应的事件处理内容

总结：**Qwik的工作原理就是在服务端序列化 HTML 模版，从而在客户端延迟创建事件处理程序，这也是它为什么非常快速的原因**

## qwik的工作机制

```jsx
// 计数器示例
export const Main = () => <>
   <Greeter />
   <Counter value={10}/>
</>

export const Greeter = () => {
  return (
    <button onClick={() => alert('Hello World!'))}>
      Trip Biz
    </button>
  )
}

export const Counter = (props: { value: number }) => {
  const store = useStore({ count: props.number || 0 });
  return (
    <button onClick={() => store.count++)}>
      {store.count}
    </button>
  )
}
```

```html
<!-- // 经过qwik编译后 -->
<div q:host>
  <div q:host>
    <!-- 元素属性标记：on:button ->  记录了该元素后续需要恢复的所有信息-->
    <!-- 这就是qwik中的序列化 -->
    <button on:click="./chunk-a.js#button">Trip Biz</button>
  </div>
  <div q:host>
    <button q:obj="1" on:click="./chunk-b.js#count[0]">10</button>
  </div>
</div>
<script id="qwikloader">/* qwik 中设置全局事件监听器的代码 */</script>
<script id="qwik/json">/* 用于反序列化的 JSON 相关信息 */</script>
```

需要注意的是序列化这一步是在服务端渲染时完成的，这也就意味着后续客户端可以通过服务端序列化的属性信息进行反序列化从而达到所谓的可恢复性而不需要重复执行组件。

当然你可能会好奇 qwik 是如何进行这些事件 & 状态的恢复，qwik 正是通过在返回的 HTML 页面中内嵌的所谓 qwikloader 的 script 脚本（这段脚本的大小不超过 1kb）配合 qwikjson 映射表，从而在全局进行恢复事件和状态的逻辑。

正因为这个原因，使得 qwik相较于传统 SSR 的 hydration 在 Client 中再次执行渲染从而水合页面状态和事件处理程序，这简直可以说是接近零 JS 的执行过程。

![qwik 的工作原理](https://pic3.zhimg.com/80/v2-bf7e87470c1035bbf73fcbd733aae5ae_1440w.webp)

总结: qwik 中既然选择在触发用户行为时，再惰性加载并执行响应的 JS 脚本。

### 预加载处理

针对于动态加载 JS 脚本，其实已经存在诸如非常多的 prefetch 等等预加载技术。

无论是基于传统 Next 方案还是基于 qwik 这种惰性可恢复的方案，利用 prefetch 等预加载技术优先在网络空闲时加载响应重要的 JS 脚本都是非常有必要的，所以这点在我看来并不是特别重要的问题。

### qwik帮我们做好了延迟加载会带来 bundle的事情

传统开发中，需要开发人员自行去处理更加细粒度的代码分割。

- 用 Magic Comments 配合 Dynaic Imports 来解决需要手动切入多个入口点的问题。
- 当存在非常多的延迟加载时，传统构建工具会从一个大 bundle 分割成为无数个小的 bundle

在qwik中都帮我们做了

### 动态创建事件函数防止内存泄漏的处理

qwik 的作者 miško hevery 在 Hydration is Pure Overhead 中明确的表示过 ，qwik 会在每次事件执行完毕后释放函数，相当于每次事件执行完毕都会进行一次"去水合"的过程
qwik 这种并不在内存中记录任何状态的方式恰恰对于内存的占用比 dyration 更加轻量化

## 总结

通过更加细粒的代码控制配合惰性加载事件处理程序以及事件委托来缩短首屏 TTI。

### qwik正在做react语法0成本转化成qwik语法的事情，未来可期


### 个人思考

1. qwik这种方式首屏的html多加了html的描述信息，会导致首屏更大。
2. qwik这种方式在链路比较长的时候，弱网的时候，点一下加载一次js脚本，可能体验更差。  不使用preload的情况下
3. qwik的这种方式，给公司节省了非常多的带宽，不关心的按钮永远不会加载这些js。 不使用preload的情况下
4. qwik属于最极致的分包策略
5. 博客类网站可以直接输出静态html，没必要服务端渲染，不适用qwik
6. 重度复杂状态交互型网站，使用qwik也不是很合适
7. qwik适合小中型ssr项目，尤其是在单路由页面，每一步交互需要的js代码很大，但是每个用户只会点击一个按钮的时候。在这种情况下，qwik应该会体验很好。 用户减少了js的加载，首屏快，公司服务器带宽压力小,cdn成本也低。qwik给做好了所有的分包策略，也不用去啃webpack复杂的分包策略，能省很多时间。 交叉剧本类型项目，点击一个选项进入一个分支剧情的那种项目。
  