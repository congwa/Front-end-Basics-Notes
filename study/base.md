# base 

## 浏览器一帧都会干些什么?

1. 接受输入事件
2. 执行事件回调
3. 开始一帧
4. 执行RAF
5. 页面布局、样式计算
6. 绘制渲染
7. 执行RIC

## 浏览器内核

### 进程

- 浏览器进程：浏览器的主进程（负责协调、主控）
  - 负责浏览器界面显示，与用户交互。网址栏输入、前进、后退等
  - 管理各个页面，创建和销毁进程
  - 将页面内容（位图）写入到浏览器内存中，最后再将图像显示在屏幕上
  - 文件储存等功能
- 渲染进程：默认一个Tab页面一个渲染进程（特殊情况：渲染进程不一定每个Tab就一个）
  - 页面渲染
  - 脚本执行
  - 事件处理等
- GPU进程：用于3d绘制等，将开启了3d绘制的元素的渲染由CPU转向GPU，也就是开启GPU加速。
- 网络进程：主要负责页面的网络资源加载，之前是作为一个模块（NetWork Thread）运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- 音频进程：浏览器音频管理

### 渲染进程

每个tab页包含一个渲染进程，渲染进程包含以下线程

- ~~GUI 渲染线程 （主线程）~~
- ~~JavaScript 引擎线程~~
- [主线程](https://baijiahao.baidu.com/s?id=1754924634013815803&wfr=spider&for=pc)
- 合成线程
- I/O线程
- 定时触发器线程
- 事件触发线程  
- 异步 http 请求线程

主线程，包括GUI+JS。所有的 JS 执行，HTML 解析和 DOM 构造，CSS 解析和计算得到 computed style，Layout，Paint（主要是决定 paint order，最终layer tree 和 paint order信息提交到 compositor 线程完成最终绘制） 等等。
其它线程，包括 worker 的，Blink 和 V8 创建的内部使用的线程（比如处理 webaudio、database）等等。
个人感觉最后一段引用里提到的「GUI 线程和 JS 线程互斥」的说法好像不太对。DOM tree/render tree 的构建和 JS 引擎应该是在同一个线程里执行的

### 外部进程通讯（react设计原理一书第二章有标明）

- 例子：外部进程(比如网络进程)通过ipc消息进行通讯到I/0线程，I/0线程发送给主线程的任务队列。

**TODO: 需要详细去学习浏览器线程通讯的方式**
猜测： 管道、消息队列、共享内存， 使用消息队列，因为不会阻塞主进程。

进程间通讯（IPC）有以下几种方式：

- 管道（Pipe）：管道是一种半双工的通信机制，一条管道只能由一个进程写，另一个进程读。
- 命名管道（Named Pipe）：与管道类似，但是它不是存在于进程的当前运行环境中，而是被命名并存储在文件系统中，因此可以被多个进程共享。
- 信号（Signal）：信号是一种异步通知机制，进程收到信号后会停止正在执行的操作并执行相应的信号处理函数。
- 消息队列（Message Queue）：消息队列是一种高级的进程间通信机制。发送方把数据放入消息队列，接收方则从消息队列中取出数据进行处理。
- 共享内存（Shared Memory）：共享内存是一种高效的进程间通信方式，将一段内存区域映射到多个进程的地址空间中，实现多个进程共享数据的目的。
- 信号量（Semaphore）：信号量是一种计数器对象，用于控制多个进程对共享资源的访问。可以用于实现互斥、同步和资源管理等。
- 套接字（Socket）：套接字是一种通用的进程间通信机制，可实现不同主机间的进程通信。

 正在为您搜索：操作系统、线程、通讯

在操作系统中，线程之间通讯有以下几种方式：

1. 共享变量：线程之间共享同一块内存区域，通过读写共享的变量来进行通信。
2. 互斥量和条件变量：通过互斥量保证线程对共享资源的互斥访问，通过条件变量实现线程之间的通讯和同步。
3. 信号量：通过 P 操作（申请操作）和 V 操作（释放操作）对共享资源进行访问和控制，并实现进程或线程之间的同步和互斥。
4. 管道：类似于进程间通信中的管道机制，用于实现进程或线程之间的单向通信。
5. 消息队列：用于多个线程或进程之间的异步通信，消息发送者将消息发送到队列中，消息接收者从队列中读取消息。

在多线程编程中，线程之间通信是非常重要的，不同的线程通信方式适用于不同的场景，需要根据实际情况进行选择。

[参考来源链接](https://zhuanlan.zhihu.com/p/105945721)]

- **TODO:重新读一遍大学的时候《操作系统原理》,开一个github读书仓库**

## 继承

    ```javascript

        // 组合式
        function Parent() {}
        function Child() {
            Parent.call(this)
        }
        Child.prototype = new Parent()
        Child.prototype.constructor = Child
        // 构造执行了两次 可以传参
        // 组合寄生
        function Child() {
            Parent.call(this)
        }
        (function() {
            const Super = function () {}
            Super.prototype = Parent.prototype
            Child.prototype = new Super()
            Child.prototype.constructor = Child
        })()
    ```

## 缓存判断

>Cache-Control ：如果是no-cache需要验证 last-Modified if-Modified-Since  / Etag  If-None-Match 来验证缓存规则

- 强缓存：未失效 cache-control优先级高于Expires 
- 强缓存：已失效 执行协商缓存，Etag的优先级高于last-Modified；
- 缓存未失效从缓存中读取304状态码
- 缓存已失效返回数据和200状态码

## XSS攻击

1. 常见使用csp进行防御攻击
2. 对输入字符串进行特殊字符转义

## CSRF攻击

1. cookie设置same-site:strict

### vw布局

### 缩放