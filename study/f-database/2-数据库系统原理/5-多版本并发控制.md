# 多版本并发控制

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式, 用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用MVCC. 可串行化隔离级别需要对所有读取的行都加锁，单纯的使用MVCC无法实现。


## 基本思想

在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因为又引入了读写锁来避免不必要的加锁操作。例如，读和读没有互斥关系。 读写锁中读和写操作仍然是互斥的，而MVCC利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本的快照，没有互斥关系，这一点和CopyOnWrite类似。

在MVCC中事务的修改操作(DELETE、INSERT、UPDATE)会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。 在事务进行读取操作时，为了解决脏读和不可重复读的问题，MVCC规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算脏读。

### CopyOnWrite 读写分离

读写分离，空间换时间，避免为保证并发安全导致的激烈的锁竞争。

1. CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率；
2. CopyOnWrite是最终一致性，在写的过程中，原有的读的数据是不会发生更新的，只有新的读才能读到最新数据；
3. 如何使其他线程能够及时读到新的数据，需要使用volatile变量；
4. 写的时候不能并发写，需要对写操作进行加锁；

其核心概念就是： 数据读取时直接读取，不需要锁，数据写入时，需要锁，且对副本进行操作。

那么当数据的操作以读取为主时，我们便可以省去大量的读锁带来的消耗。同时为了能让多线程操作List时，一个线程的修改能被另一个线程立马发现，CopyOnWriteList采用了Volatile关键词来进行修饰，即每次数据读取不从缓存里面读取，而是直接从数据的内存地址中读取。

CopyOnWriteArrayList 相对于 ArrayList 线程安全，底层通过复制数组的方式来实现

总结而言，多线程实现COW实际上就是以空间换取时间使得数据读取时不需要锁。只是减少了读锁的开销，但与常规的多线程操作共享数据的本质没有什么区别。

## 版本号

- 系统版本号SYS_ID: 是一个递增的数字，每开始一个新的事物，系统版本号就会自动递增。
- 事务版本号TRX_ID: 事务开始时的系统版本号。


## Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在MySql创建一个表T，包含主键id和一个字段x。 我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION`将上面的操作当成一个事务来执行，根据MySql的 AUTOCOMMIT机制，每个操作都会被当成一个事务来执行，所以上线的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和 操作 之外，还记录了一个 bit 的DEL字段，用于标记是否被删除。

![sw-undo](/study/imgs/sw-undo.png)

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

![1](/study/imgs/sql_undo1.awebp)
![2](/study/imgs/sql_undo2.awebp)
![3](/study/imgs/sql_undo3.awebp)
![4](/study/imgs/sql_undo4.awebp)

如此一来，这行数据在多事务场景下修改时，它的 undo log 就会形成一个 undo log 版本链作为这行数据在每个事务中的快照


举例说明：
1. 比如首先事务 A 插入一行数据值 A，同时生成 insert undo log，在事务 A 提交后，刚才生成的 undo log 就会直接被删除。
2. 紧接着事务 B 去修改这行数据为值 B，同时生成 update undo log，在事务 B 提交后，刚才生成的 undo log 不会立即删除。
3. 然后事务 C 把这行数据删除了，但是删除操作并不会直接删除数据行，而是改变数据行中 delete 标记位，标记这行数据是删除状态。
4. 等待 purge 线程在适当时机删除这行数据的 undo log 版本链。



## ReadView -需要判断一下版本链中的哪个版本是当前事务可见的


MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAXs

![sw-readView](/study/imgs/sw-readview.png)

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

READ COMMITTED —— 每次读取数据前都生成一个ReadView
REPEATABLE READ —— 在第一次读取数据时生成一个ReadView

![sql_readview](/study/imgs/sql_readview.awebp)

这个机制就是事务在读取时，会判断这行数据的 trx_id 和事务本身 ReadView 中的 min_trx_id 的大小关系，以及 trx_id 是否在 m_ids 列表中，来决定这行数据是否可读，以及用什么方式来读。ReadView 机制和 undo log 版本链形成了 MySQL 的 MVCC（Multi-Version Concurrent Control）机制（多版本并发控制机制）。



## 快照读与当前读

1. 快照读
  MVCC的SELECT操作是快照中的数据，不需要进行加锁操作。

  ```sql
  SELECT * FROM table ...;
  ```

2. 当前读
  MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

  ```sql
  INSERT;
  UPDATE;
  DELETE;
  ```

  在进行 SELECT 操作时，可以强制指定进行加锁操作。 以下第一个语句需要加 S 锁，第二个需要加 X 锁。

  ```sql
  SELECT * FROM table WHERE ? lock in share mode;
  SELECT * FROM table WHERE ? for update;
  ```

## MVCC在不同隔离级别下的表现

MVCC 机制是基于ReadView 机制和 undo log 版本链形成的。主要用来解决多事务间的脏读、不可重复读、幻读等问题，使用无锁机制提高数据库的并发性能。

SQL 标准事务隔离机制有四个级别：RU、RC、RR、S 级。MVCC 在 RC、RR 级别中使用。

### RU级别

防止多事务间的脏写，但是允许脏读。也就是说不允许修改未提交事务修改的数据行，但是允许读取未提交事务修改的数据行。

要实现这个级别，只需要在事务修改数据时添加独占锁即可。此时其它修改数据行的事务会被阻塞，只允许读取。

![ru1](/study/imgs/RU.awebp)

当事务执行完成后会唤醒等待的其它事务，并修改它们的锁状态为 false。


![ru1](/study/imgs/ru2.awebp)


## RC级别

防止多事务间的脏读，但是允许不可重复读、幻读。也就是说不允许读取未提交事务修改的数据，这个级别事务读取的数据行都是其它事务已经提交的。

这个级别的实现就需要使用 ReadView 机制和 undo log 版本链了，也就是 MVCC 机制。

首先**事务每发起一次读取都会重新生成一个 ReadView 记录查询时系统内尚未提交的事务 ID 快照**，这个是非常重要的。


![rc](/study/imgs/rc.awebp)

使用 ReadView 和 undo log 就已经达到防止脏读的目的了，因为在发起读取时，所有被修改的事务未提交的数据都不会被读取到，只会读取已提交的或者历史版本。

然后本事务再次发起读取，再生成一个新的 ReadView，此时刚才修改数据行的事务可能已经提交了，那么这时再根据 ReadView 机制进行读取，就可能读取到刚才被修改的数据了。也就产生了不可重复读的问题。如果刚才那个事务是添加操作，那么根据上述读取规则就会产生幻读的问题。


## RR级别

防止多事务间的不可重复读和幻读（只针对快照读，当前读需要加锁），也就是说事务开启后读取的数据其实就是一个快照版本，无论其它事务对数据的增删改，是否提交，都不会影响本事务对数据的查询。这个级别的实现也是需要 MVCC 机制实现的。

**与 RC 级别不同的是，这个级别的事务在开启后首次查询时会生成一个 ReadView，后续都不会对其修改**，也就是说这个事务所有的读取操作都会基于这个 ReadView 记录的事务ID快照进行读取。

就这个 ReadView 生成的区别就会让 RR 级别的事务不会产生不可重复读和幻读的问题，因为事务期间所有读取操作都是基于同一个 ReadView。

还有就是**如果数据行是 ReadView 生成后其它事务新增的，那么这行数据是不会有合适的历史版本的**。

![rr](/study/imgs/RR.awebp)

综上，RC、RR 主要区别就是 ReadView 生成的规则，就是这个规则才会使 RR 级防止幻读和不可重复读的出现。当然，上述的读，都是基于快照读而言的。


## S级别

　加锁，使所有事务串行化，可以避免所有的多事务问题。而后果也是可想而知的，将会导致 MySQL 性能及其低下。

![s](/study/imgs/S.awebp)