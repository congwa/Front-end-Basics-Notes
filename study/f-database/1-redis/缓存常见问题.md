# 缓存常见问题

## 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据

原因：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，该key没有命中，大量请求穿透到数据库服务器

解决方案：
- 对于热点数据，慎重考虑过期时间，确保热点期间key不会过期，甚至有些可以设置永不过期。
- 使用互斥锁（比如Java的多线程锁机制），第一个线程访问key的时候就锁住，等查询数据库返回后，把值插入到缓存后再释放锁

![redis_lock.webp](/study/imgs/redis_lock.webp)


## 缓存雪崩

大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

缓存服务器宕机，也算做缓存雪崩。

原因： 大量缓存在同一时间失效；大量请求落到后端DB上；

解决方案： 

- 不同的key，设置不同的过期时间(随机值)，让缓存失效的时间点尽量均匀；
- 使用高可用的分布式缓存集群，确保缓存的高可用性
  - 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2。

## 缓存穿透

访问一个一定不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉

原因： key被高并发访问；该key没有命中，去后端DB获取；大量请求穿透到数据库服务器

解决方案：

- 布隆过滤器
  - 使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤，避免对底层数据存储系统造成压力；
- 访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间

![redis_bitmap](/study/imgs/redis_bitmap.webp)

## 缓存一致性

一般情况下先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。 但是也有可能出现下面的问题

当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。（集群同步）

原因：

- 对同一个数据进行读写，在数据库层面并发的读写并不能保证完成顺序；
- 发生了写请求A，A的第一步淘汰了cache；A的第二步写数据库，发出修改请求；
- 发生了读请求B，B的第一步读取cache，发现cache中是空的；B的第二步读取数据库，发出读取请求，
- 如果A的第二步写数据还没完成，读出了一个脏数据放入cache；

解决方案：


1. 解决思路 1：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。

删除的动作，可以有多种选择，比如：1. 使用 DelayQueue，会随着 JVM 进程的死亡，丢失更新的风险；2. 放在 MQ，但编码复杂度为增加。总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案。


参考：
[缓存一致性问题](https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/redis-consistence.md)



