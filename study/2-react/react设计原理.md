# react 设计原理

## 为什么使用fiber,以及fiber的优缺点

    > 浏览器渲染进程的主线程做了太多事情，太忙了，同时只能做一件事情，React 15 的 Stack Reconciler所面临的问题，当 React在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断，js线程一直在占用资源,然后等到整棵VDOM树计算完成后，才会交给渲染的线程.
    > Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为React Element对应的Fiber节点
    > react fiber是在弥补更新时"无脑"刷新，不够精确带来的缺陷
    > 缺点 1. 链表结构占用空间 2.只能知道前后节点

## react中的副作用 - useEffect 清除副作用函数

如果在 useEffect 函数中返回一个函数，那么这个函数就是清除函数，它会在组件销毁的时候执行，但是其实，它会在组件每次重新渲染时执行，并且清除上一个 effect 的副作用
> 副作用是指一个 function 做了和本身运算返回值无关的事，比如：修改了全局变量、修改了传入的参数、甚至是 console.log()，所以 ajax 操作，修改 dom ，计时器，其他异步操作，其他会对外部产生影响的操作都是算作副作用, 外部数据同步(比如setTimeOut过来的数据，react的纯函数的概念，外部数据破坏了纯函数，作为下次输入一起处理)，保证react本次内部渲染流程准确流畅, 还有用户交互改变了dom等也在渲染之后进行计算和应用。

Effect 的清除同样被延迟了，上一次的 effect 会在重新渲染后被清除

effect 的清除并不会读取最新的 props，它只能读取到定义它的那次渲染中的 props 值。


比如定时器引发的数据要放在useEffect中处理，因为外部数据进行同步，放到下一次更新中处理，不能影响本次更新流程