
# ⚛️ React Fiber 架构与并发渲染深度解析

本文档是对 React Fiber 架构、空闲渲染、优先级调度、工作中断与恢复，以及提交阶段一致性保证机制的全面整理和详细问答记录。

-----

## 问答一：什么是 Fiber 架构？空闲渲染有了解吗？

### 什么是 Fiber 架构？

**Fiber 架构** 是 React 16 引入的全新协调器（Reconciler）架构，旨在解决之前版本中**同步递归渲染**导致的性能瓶颈（如主线程阻塞和界面卡顿）。

**核心理念：** 将渲染工作分解成小的、**可中断**的工作单元。

  * **可中断和可恢复：** 以前的协调器（Stack Reconciler）是递归的，一旦开始就无法中断。Fiber 将工作拆分成 Fiber 节点，可以在渲染过程中暂停、让出主线程给浏览器，稍后再恢复执行。
  * **异步渲染 (Asynchronous Rendering)：** 通过可中断性，React 可以在不阻塞浏览器主线程的情况下进行工作，实现更流畅的用户体验。

### Fiber 节点（工作单元）

每个组件对应一个 **Fiber 节点**，它是一个 JavaScript 对象，保存了该组件的：

  * **静态信息：** 组件的类型、`key` 等。
  * **动态信息：** 本次更新中该组件需要执行的工作，以及指向父节点 (`return`)、子节点 (`child`) 和兄弟节点 (`sibling`) 的指针。

### 什么是空闲渲染 (Idle Time Rendering)？

**空闲渲染** 是 Fiber 架构实现异步渲染的一种方式，即**利用浏览器空闲时间**来执行优先级较低的渲染工作。

  * **浏览器空闲时间：** 指浏览器完成了当前渲染帧的工作，在等待下一帧绘制前的短暂时间。
  * **运作方式：** React 会利用这段空闲时间来执行**非紧急**的渲染计算，而不是阻塞主线程立即执行。如果空闲时间用完，工作会暂停，等待下一次空闲时再恢复。

-----

## 问答二：哪些 API 会利用空闲渲染？

用来实现空闲渲染的核心机制是利用了浏览器提供的原生 Web API：

### 核心 API：`window.requestIdleCallback()`

  * **用途：** 允许开发者将一个回调函数（低优先级的任务）排队，以便在浏览器的**空闲时段**执行。
  * **Fiber 的应用：** React Fiber 利用这个 API 来调度**低优先级**的渲染工作。

### 相关 API 及其区别

| API | 用途 | 调度时机 | 优先级 |
| :--- | :--- | :--- | :--- |
| **`requestIdleCallback()`** | 用于非关键、非视觉同步的任务。 | 浏览器**空闲时**。 | **低优先级** |
| **`requestAnimationFrame()`** | 用于高优先级、与视觉刷新同步的任务（如动画）。 | 浏览器下一次重绘**之前**。 | **高优先级** |

**用户层面 API：** 在用户层面，开发者通常使用 **`startTransition`** (React 18+) 来标记非紧急更新，该 API 内部依赖 Fiber 的调度系统（包括空闲调度思想）来实现其效果。

-----

## 问答三：Fiber 如何确认高优先级和低优先级的？

Fiber 确认任务优先级主要依赖于**任务来源**和 **React 内部的调度器 (Scheduler)**。

### 1\. 优先级的来源和划分

React 根据更新的**紧急程度**和它与**用户交互**的关联性来赋予优先级常量：

| 优先级等级 | 对应场景 | 调度预期 |
| :--- | :--- | :--- |
| **高（同步/Immediate）** | 生命周期方法、同步批处理更新。 | 必须立即同步执行。 |
| **中（User-Blocking）** | 用户输入（打字、点击）引起的更新。 | 必须尽快执行。 |
| **低（Transition/Low）** | 普通 `setState`、非紧急过渡更新。 | 可中断，可在浏览器空闲时执行。 |
| **最低（Idle）** | 不影响 UI 的后台任务。 | 只有在主线程完全空闲时才执行。 |

### 2\. 调度器 (Scheduler) 的作用

Scheduler 是一个独立模块，负责管理任务队列并映射优先级：

  * **管理任务队列：** 使用**优先级队列**（小顶堆）存储待执行的 Fiber 工作单元。
  * **映射调度策略：** 将抽象优先级映射为实际的浏览器 API 和调度策略。
      * **高优先级：** 使用 `MessageChannel` 或 `requestAnimationFrame` 尽快执行。
      * **低优先级：** 分配较短的**时间切片**，并利用 `requestIdleCallback` 思想，允许随时中断和恢复。

-----

## 问答四：`setState` 导致多帧都中断了，中断的每一帧 `setState` 的值都更新了。

这是一个并发渲染的典型现象，是 **可中断性** 和 **“有状态的工作单元”** 的结果。

### 核心机制

1.  **工作可中断：** Fiber 协调过程可以在任何 Fiber 节点计算完成后暂停，让出主线程。
2.  **新更新介入：** 在中断期间，如果有新的状态更新 $S_2$ 到达，它会被调度器接收。
3.  **恢复与采纳最新状态：** 当 Fiber 协调器恢复工作时，它会检查并采纳**最新的**、尚未应用的 State **更新队列**中的值。它不会使用旧状态 $S_1$ 的结果继续计算，而是使用 $S_2$ **重新开始或继续**计算，确保最终的渲染结果是基于最接近用户的状态。

**目的：** 确保高优先级的任务（如用户输入）能“插队”，并避免用旧状态进行不必要的计算。

-----

## 问答五：怎么让出主线程的？

**“让出主线程”** 意味着**暂停当前正在执行的 JavaScript 代码**，让浏览器有机会处理用户的输入、进行动画绘制等。

### 实现“让出”的机制

1.  **细粒度工作：** Fiber 将工作分解到 `performUnitOfWork`，使其能在处理完一个 Fiber 节点后，有机会检查是否需要让出。
2.  **检查点：** 在主循环中通过 **`shouldYield()`**（检查时间切片或高优先级任务）来判断是否需要暂停。
3.  **暂停与恢复：** 当需要让出时，立即停止当前的 `while` 循环，并通过异步 API（如 `requestAnimationFrame`）将 `workLoop` 函数本身**安排到未来的某个时刻再次执行**。

### 让出流程伪代码（简化）

```javascript
function workLoop() {
    while (nextUnitOfWork !== null) {
        if (shouldYield()) {
            // 暂停循环
            // 请求下一帧恢复 workLoop
            requestNextUpdate(workLoop); 
            return; // 立即返回，让出主线程
        } 
        
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
    // ... 如果工作完成，进入 Commit 阶段
}
```

-----

## 问答六：多次循环如何确定最新状态？

状态的“最新性”是通过在**协调阶段**不断更新 **工作在制品树 (WIP Tree)** 来保证的。

### 关键机制：更新队列与状态查找

1.  **状态存储：** 所有的状态更新（包括中断期间发生的）都以**更新对象**的形式，被推入到其对应 Fiber 节点的**更新队列**中。
2.  **协调器采纳：** 当协调器到达某个 Fiber 节点并执行逻辑时，它会**集中处理**队列中的所有更新，并计算出**最终的、最新的状态**。
3.  **工作废弃（Work Abandonment）：** 如果一个高优先级新更新 $S_2$ 介入，Fiber 会：
      * **优先级高 ($P(S_2) > P(S_1)$)：** **废弃**基于 $S_1$ 的旧 WIP 树，从根节点**重新开始**协调，确保使用 $S_2$。
      * **优先级相同或低：** 继续在旧 WIP 树上工作，但恢复时会重新执行组件逻辑，应用队列中最新的 $S_2$ 结果，覆盖旧的 $S_1$ 结果。

-----

## 问答七：在这种情况下，状态的传染性怎么解决的？

“状态的传染性”指一个状态更新如何安全地影响其子树，而不会在可中断阶段导致界面不一致。

### 核心解决机制：隔离、纯净性与延迟副作用

1.  **WIP 树的局部更新：** 所有状态的计算和差异对比都发生在**内存中的 WIP 树**上。状态的向下“传染”仅仅是**数据流的传递**（通过 Props），不会对用户可见的 DOM 产生任何影响。
2.  **协调阶段的纯净性：** Fiber 强制要求在协调阶段（可中断阶段）组件逻辑必须是**纯净的（Pure）**，**不能有副作用**（如修改 DOM、发起网络请求）。
3.  **副作用延迟：** 所有实际的副作用（真正的“传染性”体现）——例如修改 DOM、执行 `useEffect`——都被推迟到 **提交阶段（Commit Phase）** 执行。

-----

## 问答八：Commit Phase 如何在同步阶段安全地处理所有累积的副作用和状态“传染”，从而保证界面的一致性？

提交阶段是 **同步、不可中断** 的，它将内存中的 WIP 树结果**一次性**应用到 DOM 上，保证一致性。

### 提交阶段的详细流程（三个同步子阶段）

| 阶段 | 目标 | 关键执行内容 | 一致性保证机制 |
| :--- | :--- | :--- | :--- |
| **1. Before Mutation** | 读取 DOM 状态 | 调用 `getSnapshotBeforeUpdate`，处理 `useLayoutEffect` 清理。 | 在 DOM 变更前获取所需的几何信息。 |
| **2. Mutation** | 执行 DOM 操作 | 遍历 **`Effect List`**，执行所有 DOM 增、删、改操作。 | **原子性更新：** 整个过程同步完成，确保用户不会看到不一致的中间状态。 |
| **3. Layout** | DOM 操作后 | 执行 `useLayoutEffect` 回调、`componentDidMount/Update`。切换 Fiber 树。 | 依赖最新的 DOM 布局执行副作用，并在最后完成双缓存切换。 |

### 一致性保证总结

  * **同步执行与原子性：** 整个提交阶段是同步且一次性完成的，所有 DOM 变更作为一个原子操作发生。
  * **Effect List 优化：** 只遍历被标记有副作用的节点，高效且集中地处理状态“传染”的最终结果。
  * **阶段分离：** 严格分离 DOM 读取（Before Mutation）和 DOM 写入（Mutation），防止副作用交叉干扰。