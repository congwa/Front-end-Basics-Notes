# 智能重排序

**详细实现：**
```python
class SmartReranker:
    def __init__(self, cross_encoder_model="cross-encoder/ms-marco-MiniLM-L-6-v2"):
        self.cross_encoder = CrossEncoder(cross_encoder_model)
        
    def rerank(
        self, 
        query: str, 
        documents: List[Document],
        top_k: int = 10
    ) -> List[Document]:
        # 1. 准备文档对
        pairs = [(query, doc.page_content) for doc in documents]
        
        # 2. 计算相关性分数
        scores = self.cross_encoder.predict(pairs)
        
        # 3. 结合多个特征进行排序
        reranked_docs = self._combine_features_and_sort(
            documents, scores, query)
        
        return reranked_docs[:top_k]
    
    def _combine_features_and_sort(
        self,
        documents: List[Document],
        cross_encoder_scores: np.ndarray,
        query: str
    ) -> List[Document]:
        scored_docs = []
        for doc, cross_score in zip(documents, cross_encoder_scores):
            # 计算其他特征
            features = {
                'cross_encoder_score': cross_score,
                'bm25_score': self._calculate_bm25(query, doc),
                'freshness_score': self._calculate_freshness(doc),
                'length_score': self._calculate_length_score(doc)
            }
            
            # 计算最终分数
            final_score = self._calculate_final_score(features)
            
            scored_docs.append((doc, final_score))
            
        # 按分数排序
        return [doc for doc, _ in sorted(
            scored_docs, 
            key=lambda x: x[1], 
            reverse=True
        )]
```

**优化策略：**
1. 特征工程
   ```python
   class FeatureExtractor:
       def extract_features(
           self, 
           query: str, 
           document: Document
       ) -> Dict[str, float]:
           return {
               'lexical_match': self._compute_lexical_match(query, document),
               'semantic_similarity': self._compute_semantic_sim(query, document),
               'document_quality': self._assess_doc_quality(document),
               'query_coverage': self._compute_query_coverage(query, document)
           }
   ```

2. 动态权重学习
   ```python
   class DynamicWeightLearner:
       def learn_weights(
           self, 
           training_data: List[Tuple[str, Document, float]]
       ) -> Dict[str, float]:
           # 使用机器学习模型学习特征权重
           X = []  # 特征矩阵
           y = []  # 相关性标签
           
           for query, doc, relevance in training_data:
               features = self.feature_extractor.extract_features(query, doc)
               X.append(list(features.values()))
               y.append(relevance)
           
           # 训练模型
           model = LightGBM()
           model.fit(X, y)
           
           # 获取特征重要性作为权重
           feature_names = list(features.keys())
           weights = dict(zip(feature_names, model.feature_importances_))
           
           return weights
   ``` 