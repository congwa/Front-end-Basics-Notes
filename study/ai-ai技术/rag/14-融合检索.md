# 融合检索

**详细实现：**
```python
class HybridRetriever:
    def __init__(
        self,
        semantic_retriever,
        keyword_retriever,
        reranker
    ):
        self.semantic_retriever = semantic_retriever
        self.keyword_retriever = keyword_retriever
        self.reranker = reranker
        
    def retrieve(
        self, 
        query: str,
        top_k: int = 10
    ) -> List[Document]:
        # 1. 并行执行多种检索
        semantic_results = self.semantic_retriever.retrieve(query)
        keyword_results = self.keyword_retriever.retrieve(query)
        
        # 2. 合并结果
        merged_results = self._merge_results(
            semantic_results,
            keyword_results
        )
        
        # 3. 重新排序
        reranked_results = self.reranker.rerank(
            query, merged_results)
        
        return reranked_results[:top_k]
    
    def _merge_results(
        self,
        semantic_results: List[Document],
        keyword_results: List[Document]
    ) -> List[Document]:
        # 使用集合去重
        seen_contents = set()
        merged = []
        
        for doc in semantic_results + keyword_results:
            if doc.page_content not in seen_contents:
                seen_contents.add(doc.page_content)
                # 合并相似度分数
                doc.metadata['combined_score'] = (
                    doc.metadata.get('semantic_score', 0) +
                    doc.metadata.get('keyword_score', 0)
                )
                merged.append(doc)
                
        return merged
```

**最佳实践：**
1. 检索策略组合
   ```python
   class RetrievalStrategyManager:
       def select_strategies(self, query: str) -> List[str]:
           query_features = self._analyze_query(query)
           
           strategies = []
           if query_features['is_keyword_rich']:
               strategies.append('keyword')
           if query_features['needs_semantic']:
               strategies.append('semantic')
           if query_features['is_complex']:
               strategies.append('hybrid')
               
           return strategies
   ```

2. 动态权重调整
   ```python
   class DynamicWeightAdjuster:
       def adjust_weights(
           self,
           query: str,
           retrieval_results: Dict[str, List[Document]]
       ) -> Dict[str, float]:
           # 基于检索结果质量动态调整权重
           weights = {}
           for method, results in retrieval_results.items():
               quality_score = self._evaluate_results_quality(
                   query, results)
               weights[method] = self._calculate_weight(
                   quality_score)
           
           return self._normalize_weights(weights)
   ``` 