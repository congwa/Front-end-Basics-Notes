# io模型

## 阻塞IO

当发起一个IO操作时，比如读取数据，系统会调用read()函数。如果请求的数据没有准备好，此时进程会被挂起（blocked），进入等待状态。直到数据准备好，而且复制到应用进程的缓冲区，这时候才会返回。

从调用到返回，整个时间段都是阻塞的，所以被称为阻塞IO

## 非阻塞IO

阻塞IO，还是比较浪费资源的

所谓非阻塞IO，是在调用IO操作时，如果缓冲区没有数据的话，直接返回一个错误码。

应用进程需要不断轮询，来检查数据是否准备好。数据准备好了，就返回数据。

## 多路复用IO

虽然非阻塞IO相比阻塞IO，性能提升了很多，但是轮询过程中，还是有大量的系统调用，上下文切换的开销比较大。


多路指的是多个数据通道，复用指的是一个进程可以同时监控多个文件描述符（比如socket），当某个文件描述符状态发生变化（比如变得可读或可写），多路复用的函数将返回变化的文件描述符。

这样，在数据传输过程中，同一个进程中不同的任务都能被处理。特点是在数据传输过程中，进程能够同时处理多个任务，提高了程序的效率。

select、poll、epoll 等都是 I/O 多路复用的具体实现。

以select/poll为例，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以侦测多个fd是否处于就绪状态。当有fd就绪时，立即回调函数rollback，接下来就可以进行读取。

![多路复用](/study/imgs/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io.png)

I/O多路复用解决了在同一个线程内同时处理多个IO请求的目的

而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的

## 信号驱动式IO

信号驱动式IO利用信号机制来进行数据传输。

进程首先告诉内核，当数据准备好时，请发送一个SIGIO信号。进程继续执行其他任务，等到收到信号后，再开始进行数据传输。

![信号驱动io](/study/imgs/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png)

就像是我去吃饭，外带，跟服务员打声招呼，餐好了通知我，这时候我就可以去干其它事情，餐备好之后，服务员通知我，我取餐就行了。

![信号驱动io](/study/imgs/%E4%BF%A1%E5%8F%B7io.png)

通过sigaction系统调用安装信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个sIgIo信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好，也可以立即通知主循环，让它读取数据报。，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知。

**优点**：相较于非阻塞IO，因为信号到来后就直接强行中断进行处理，更加实时。并且在没收到信号的时候可以执行其他工作，资源利用更加充分

**缺点**：因为需要自定义信号，又要有主控流程也要有信号处理流程，并且还需要考虑信号是否可靠导致的事件丢失情况，流程会更加的复杂。

## 异步I/O

异步I/O是指当发起一个IO操作后，系统会立即返回。异步I/O操作在后台进行数据传输，数据传输完成后，系统将通知进程。这样，在整个数据传输的过程中，进程都可以执行其他任务，不需要等待。


![异步i/o](/study/imgs/%E5%BC%82%E6%AD%A5io.png)

可以看到，阻塞和非阻塞主要指的是等待数据这个过程应用进程需不需要挂起，同步和异步指的是等待数据和数据拷贝这两个过程应用进程需不需要挂起，只有异步I/O做到了完全异步。

一般采用事件循环机制，由用户控制，使用操作系统提供的非阻塞 I/O 接口和事件通知机制，如使用 select、poll、epoll 等系统调用来监听多个 I/O 事件

由上可以看出，一般用于处理epoll事件，所以说异步i/o是一个编程模型。 当然也可以使用select、pull、epoll的模型来处理底层的I\O事件。





