# io模型

## 阻塞IO

当发起一个IO操作时，比如读取数据，系统会调用read()函数。如果请求的数据没有准备好，此时进程会被挂起（blocked），进入等待状态。直到数据准备好，而且复制到应用进程的缓冲区，这时候才会返回。

从调用到返回，整个时间段都是阻塞的，所以被称为阻塞IO

## 非阻塞IO

阻塞IO，还是比较浪费资源的

所谓非阻塞IO，是在调用IO操作时，如果缓冲区没有数据的话，直接返回一个错误码。

应用进程需要不断轮询，来检查数据是否准备好。数据准备好了，就返回数据。

## 多路复用IO

虽然非阻塞IO相比阻塞IO，性能提升了很多，但是轮询过程中，还是有大量的系统调用，上下文切换的开销比较大。


多路指的是多个数据通道，复用指的是一个进程可以同时监控多个文件描述符（比如socket），当某个文件描述符状态发生变化（比如变得可读或可写），多路复用的函数将返回变化的文件描述符。

这样，在数据传输过程中，同一个进程中不同的任务都能被处理。特点是在数据传输过程中，进程能够同时处理多个任务，提高了程序的效率。

select、poll、epoll 等都是 I/O 多路复用的具体实现。

以select/poll为例，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以侦测多个fd是否处于就绪状态。当有fd就绪时，立即回调函数rollback，接下来就可以进行读取。

![多路复用](/study/imgs/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io.png)

I/O多路复用解决了在同一个线程内同时处理多个IO请求的目的

而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的

## 信号驱动式IO

信号驱动式IO利用信号机制来进行数据传输。

进程首先告诉内核，当数据准备好时，请发送一个SIGIO信号。进程继续执行其他任务，等到收到信号后，再开始进行数据传输。

![信号驱动io](/study/imgs/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.png)

就像是我去吃饭，外带，跟服务员打声招呼，餐好了通知我，这时候我就可以去干其它事情，餐备好之后，服务员通知我，我取餐就行了。

## 异步io

异步IO是指当发起一个IO操作后，系统会立即返回。异步IO操作在后台进行数据传输，数据传输完成后，系统将通知进程。这样，在整个数据传输的过程中，进程都可以执行其他任务，不需要等待。


![异步io](/study/imgs/%E5%BC%82%E6%AD%A5io.png)

可以看到，阻塞和非阻塞主要指的是等待数据这个过程应用进程需不需要挂起，同步和异步指的是等待数据和数据拷贝这两个过程应用进程需不需要挂起，只有异步IO做到了完全异步。


