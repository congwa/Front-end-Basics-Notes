# ipc

操作系统内的并发执行进程可以是独立的也可以是协作的：

- 如果一个进程不能影响其他进程或受其他进程影响，那么该进程是独立的，换句话说，不与任何其他进程共享数据的进程是独立的；
- 如果一个进程能影响其他进程或受其他进程所影响，那么该进程是协作的。换句话说，与其他进程共享数据的进程为协作进程。

提供环境允许进程协作，具有许多理由：

- 信息共享：由于多个用户可能对同样的信息感兴趣（例如共享文件），所以应提供环境以允许并发访问这些信息。
- 计算加速：如果希望一个特定任务快速运行，那么应将它分成子任务，而每个子任务可以与其他子任务一起并行执行。注意，如果要实现这样的加速，那么计算机需要有多个处理核。
- 模块化：可能需要按模块化方式构造系统，即将系统功能分成独立的进程或线程。
- 方便：即使单个用户也可能同时执行许多任务。例如，用户可以并行地编辑、收听音乐、编译。
  
协作进程需要有一种**进程间通信机制（简称 IPC）**，以允许进程相互交换数据与信息。进程间通信有两种基本模型：共享内存和消息传递（消息队列）

- 共享内存模型会建立起一块供协作进程共享的内存区域，进程通过向此共享区域读出或写入数据来交换信息。
- 消息传递模型通过在协作进程间交换消息来实现通信。

![模型对比](http://c.biancheng.net/uploads/allimg/181102/2-1Q1021345313P.gif)

- 消息传递对于交换较少数量的数据很有用
- 对于分布式系统，消息传递也比共享内存更易实现
- 共享内存可以快于消息传递，这是因为消息传递的实现经常采用系统调用，因此需要消耗更多时间以便内核介入
- 共享内存系统仅在建立共享内存区域时需要系统调用
- 一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核

## 共享内存

共享内存区域驻留在创建共享内存段的进程地址空间内。其他希望使用这个共享内存段进行通信的进程应将其附加到自己的地址空间。

- 基于约定： 通常操作系统试图阻止一个进程访问另一进程的内存。共享内存需要两个或更多的进程同意取消这一限制
- 解决生产者-消费者问题的方法之一是采用共享内存
  - 为了允许生产者进程和消费者进程并发执行，应有一个可用的缓冲区，以被生产者填充和被消费者清空。
  - 这个缓冲区驻留在生产者进程和消费者进程的共享内存区域内
  - 当消费者使用一项时，生产者可产生另一项
  - 生产者和消费者必须同步，这样消费者不会试图消费一个尚未生产出来的项

缓冲区分类：

- **无界缓冲区**：没有限制缓冲区的大小。消费者可能不得不等待新的项，但生产者总是可以产生新项。
- **有界缓冲区**： 假设固定大小的缓冲区。对于这种情况，如果缓冲区空，那么消费者必须等待；并且如果缓冲区满，那么生产者必须等待。

## 消息队列

操作系统提供机制，协作进程通过消息传递功能进行通信。允许进程不必通过共享地址空间来实现通信和同步。对分布式环境（通信进程可能位于通过网络连接的不同计算机），这特别有用。

进程发送的消息

- 定长：只能发送定长消息
- 变长：可以发送变长消息

实现消息队列需要**通讯链路*:

- 共享内存
- 硬件总线
- 网络

用于逻辑实现链路和操作 send()/receive()：

- 直接或间接的通信;
- 同步或异步的通信;
- 自动或显式的缓冲;

### 命名

需要通信的进程应有一个方法，以便互相引用。它们可以使用直接或间接的通信。

### 直接通讯

寻址对称性:需要通信的每个进程必须明确指定通信的接收者或发送者。采用这种方案，原语 send() 和 receive() 定义如下：

- send(P,message)：向进程P发送 message
- receive(Q,message)：从进程 Q 接收 message。
  
这种方案的通信链路具有以下属性：

- 在需要通信的每对进程之间，自动建立链路。进程仅需知道对方身份就可进行交流。
- 每个链路只与两个进程相关。
- 每对进程之间只有一个链路。

寻址的非对称性:只要发送者指定接收者，而接收者不需要指定发送者

- send(P，message)：向进程 P 发送 message
- receive(id, message)：从任何进程，接收 message，这里变量 id 被设置成与其通信进程的名称

这两个方案（对称和非对称的寻址）的缺点是：生成进程定义的有限模块化。更改进程的标识符可能需要分析所有其他进程定义。所有旧的标识符的引用都应找到，以便修改成为新标识符。通常，任何这样的硬编码技术（其中标识符需要明确指定），与下面所述的采用间接的技术相比要差。

### 间接通讯

通过邮箱或端口来发送和接收消息。
邮箱可以抽象成一个对象，进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。

原语：

- send(A, message)：向邮箱 A 发送 message。
- receive(A，message)：从邮箱 A 接收 message。

通信链路具有如下特点：

- 只有在两个进程共享一个邮箱时，才能建立通信链路。
- 一个链路可以与两个或更多进程相关联。
- 两个通信进程之间可有多个不同链路，每个链路对应于一个邮箱。

### 同步与异步

进程间通信可以通过调用原语 send() 和 receive() 来进行。实现这些原语有不同的设计方案。消息传递可以是阻塞或非阻塞，也称为同步或异步：

- 阻塞发送：发送进程阻塞，直到消息由接收进程或邮箱所接收。
- 非阻塞发送：发送进程发送消息，并且恢复操作。
- 阻塞接收：接收进程阻塞，直到有消息可用。
- 非阻塞接收：接收进程收到一个有效消息或空消息。

### 缓存

不管通信是直接的还是间接的，通信进程交换的消息总是驻留在临时队列中。
队列实现有三种方法：

- 零容量：队列的最大长度为 0。因此，链路中不能有任何消息处于等待。对于这种情况，发送者应阻塞，直到接收者接收到消息。
- 有限容量：队列长度为有限的 n。因此，最多只能有 n 个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可以继续执行而不必等待。如果链路已满，那么发送者应阻塞，直到队列空间有可用的为止。
- 限容量：队列长度可以无限，因此，不管多少消息都可在其中等待。发送者从不阻塞。

零容量情况称为无缓冲的消息系统，其他情况称为自动缓冲的消息系统。