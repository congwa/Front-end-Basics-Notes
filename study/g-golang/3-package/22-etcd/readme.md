# etcd

## 提问解答

1. 为什么需要分布式事务？为什么会引发分布式事务问题。

  > 假设一个电商平台的订单支付流程包含了多个服务，比如生成订单、扣减库存、生成支付记录等等，这些服务都是独立部署，拥有独立的数据库实例。如果支付成功，所有服务都需要提交事务，而如果支付失败，则所有服务都需要回滚事务，以保证数据的一致性.

2. 为什么需要选举Leader?
   选举Leader是分布式设计模式中的一种。

   假设有一个服务需要多个节点同时执行（系统的订单服务一共部署了 3 份，都对外提供服务），那么就需要使用选举Leader来实现。某一个节点出现故障，那么基于一些复杂的交互，选举其它节点，并且不丢数据。

3. 为什么需要分布式锁？
    使用分布式锁的目的，无外乎就是保证同一时间只有一个客户端可以对共享资源进行操作
    - (1)允许多个客户端操作共享资源 - 这种情况下，对共享资源的操作一定是幂等性操作，无论你操作多少次都不会出现不同结果。在这里使用锁，无外乎就是为了避免重复操作共享资源从而提高效率。
    - (2)只允许一个客户端操作共享资源 - 这种情况下，对共享资源的操作一般是非幂等性操作。在这种情况下，如果出现多个客户端操作共享资源，就可能意味着数据不一致，数据丢失。

    举例

    系统的订单服务一共部署了 3 份，都对外提供服务，用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。（当前操作进入临界区）





自己实现分布式环境的并发原语，是相当困难的一件事，因为你需要考虑网络的延迟和异常、节点的可用性、数据的一致性等多种情况

所以，我们可以借助 etcd 这样成熟的框架，基于它提供的分布式并发原语处理分布式的场景。

需要注意的是，在使用这些分布式并发原语的时候，你需要考虑异常的情况，比如网络断掉等。同时，分布式并发原语需要网络之间的通讯，所以会比使用标准库中的并发原
语耗时更长。

## 并发原语

### Leader选举

1. 选举
   - Campaign:把一个节点选举为主节点,并且会设置一个值
   - Proclaim:重新设置Leader的值,但是不会重新选主
   - Resign:开始新一次选举
2. 查询
   - Leader:可以使用这个方法来查询主节点信息
   - Rev方法:每次主节点的变动都会生成一个新的版本号,可以查询版本号信息,了解主节点变动情况
3. 监控
   - Observe:监控主的变化


### 互斥锁

1. Locker
2. Mutex

### 读写锁

- etcd提供的读写帧,可以在分布式环境中的不同的节点使用
- 提供的方法
  - RLock/RUnlock
  - Lock/Unlock


## 分布式队列和优先级队列


etcd 通过`github.com/coreos/etcd/contrib/recipes` 包提供了分布式队列这种数据结构.

这个队列只有两个方法，分别是出队和入队，队列中的元素是字符串类型。

```go
// 入队
func (q *Queue) Enqueue(val string) error
//出队
func (q *Queue) Dequeue() (string, error)
```

需要注意的是，如果这个分布式队列当前为空，调用 Dequeue 方法的话，会被阻塞，直到有元素可以出队才返回。

优先级队列 PriorityQueue， 可以在一个节点输入一些不同优先级的元素，在另外一个节点读取出来


## 分布式栅栏

一组节点协同工作，共同等待一个信号，在信号未出现前，这些节点会被阻塞住，而一旦信号出现，这些阻塞的节点就会同时开始继续执行下一步的任务。


- Barrier：分布式栅栏
  如果持有 Barrier 的节点释放了它，所有等待这个 Barrier 的节点就不会被阻塞，而是会继续执行
  - Hold 方法是创建一个 Barrier。如果 Barrier 已经创建好了，有节点调用它的 Wait 方法，就会被阻塞
  - Release 方法是释放这个 Barrier，也就是打开栅栏。如果使用了这个方法，所有被阻塞的节点都会被放行，继续执行
  - Wait 方法会阻塞当前的调用者，直到这个 Barrier 被 release。如果这个栅栏不存在，调用者不会被阻塞，而是会继续执行
- DoubleBarrier：计数型栅栏
  在初始化计数型栅栏的时候，我们就必须提供参与节点的数量，当这些数量的节点都 Enter 或者 Leave 的时候，这个栅栏就会放开。所以，我们把它称为计数型栅栏


## STM

etcd 提供了在一个事务中对多个 key 的更新功能，这一组 key 的操作要么全部成功，要么全部失败。etcd 的事务实现方式是基于 CAS 方式实现的，融合了 Get、Put 和 Delete操作

分为条件块、成功块和失败块，条件块用来检测事务是否成功，`如果成功，就执行 Then(...)，如果失败，就执行 Else(...)`：

```GO
Txn().If(cond1, cond2, ...).Then(op1, op2, ...,).Else(op1’, op2’, …)
```

因为事务使用起来非常麻烦，所以 etcd 又在这些基础 API 上进行了封装，新增了一种叫做 STM 的操作，提供了更加便利的方法


使用 STM，你需要先编写一个 apply 函数，这个函数的执行是在一个事务之中的

```go
apply func(STM) error
```

这个方法包含一个 STM 类型的参数，它提供了对 key 值的读写操作。

STM 提供了 4 个方法，分别是 Get、Put、Receive 和 Delete，代码如下：

```go
type STM interface {
  Get(key ...string) string
  Put(key, val string, opts ...v3.OpOption)
  Rev(key string) int64
  Del(key string)
}
```