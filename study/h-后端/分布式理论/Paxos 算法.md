# Paxos 算法 （崩溃容错算法）

多个节点之间如何就某个值达成共识

共识算法基本都需要解决两个基本问题:
1. 如何提出一个需要达成共识的提案 (选举leader、随机投票)
2. 如何让多个节点对提案达成共识 (广播、复制、投票)

## 应用

无中心多节点备份，核心思想就是通过paxos算法实现操作串行化。（每个节点都是主节点）

- 定义操作序列：在Paxos算法中，每个节点都会收到来自客户端的操作请求。为了实现操作串行化，首先需要对来自不同客户端的操作进行序列化。可以为每个操作分配一个全局唯一的序列号。
- 协商提案：利用Paxos算法的提案协商过程，将操作序列作为提案发送给其他节点，等待大多数节点的接受意见。
- 判断顺序：当一个提案获得共识后，每个节点按照提案中的序列号顺序执行操作。节点通过判断操作的序列号来确定操作的顺序，从而实现串行化。
- 冲突处理：如果存在冲突的操作，例如两个操作试图修改相同数据项，需要根据具体策略解决冲突。可以选择拒绝其中一个操作、延迟其中一个操作或者通过其他方式解决冲突。

选主（由于此算法的耗时的特性，一般都选择用raft算法，raft算法选出来的是日志最全的。但是raft有单点依赖问题和切换Leader的时候拒绝服务的问题，可用性相对较差）

假设现在有四台机器，其中一台收到了来自客户端的写操作请求，需要同步给其他机器。此时这台收到请求的机器，我们称它为Proposer，因为它将要开始将收到的请求，作为一个提案，提给其他的机器。此时，其他的Acceptor都闲着呢，也没其他人找，所以当它们收到Proposer的提案时，就直接投票了，说可以可以，我是空的，赞成提案（同意提议）。Prepare阶段：Proposer告诉所有其他机器，我这里有一个提案（操作），想要你们投投票支持一下，想听听大家的意见。Acceptor看自己是NULL，也就是目前还没有接受过其他的提案，就说我肯定支持。Accept阶段：Proposer收到其他机器的回复，说他们都是空的，也就是都可以支持接受Proposer的提案（操作），于是正式通知大家这个提案被集体通过了，可以生效了，操作就会被同步到所有机器正式生效。

PaxosStore- 微信后台分布式存储数据库，就是这样的一个分布式数据库。微信的PaxosStore还是选择了Paxos，甚至它都没有选择Multi-Paxos，而是Basic-Paxos，就是为了进一步避免单点依赖和切换Leader时的拒绝服务，来提高可用性。

## 三个角色

- 提议者（Proposer）：提议一个值，用于投票表决。为了方便演示，你可以把图 1 中的客户端 1 和 2 看作是提议者。但在绝大多数场景中，集群中收到客户端请求的节点，才是提议者（图 1 这个架构，是为了方便演示算法原理）。这样做的好处是，对业务代码没有入侵性，也就是说，我们不需要在业务代码中实现算法逻辑，就可以像使用数据库一样访问后端的数据。
- 接受者（Acceptor）：对每个提议的值进行投票，并存储接受的值，比如 A、B、C 三个节点。 一般来说，集群中的所有节点都在扮演接受者的角色，参与共识协商，并接受和存储数据。
- 学习者（Learner）：被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。一般来说，学习者是数据备份节点，比如“Master-Slave”模型中的 Slave，被动地接受数据，容灾备份。

![paxos_1](/study/imgs/paxos_1.png)


提议者代表的是接入和协调功能，收到客户端请求后，发起二阶段提交，进行共识协商；

接受者代表投票协商和存储数据，对提议的值进行投票，并接受达成共识的值，存储保存；

学习者代表存储数据，不参与共识协商，只接受达成共识的值，存储保存。


## 达成共识过程

使用[n, v]表示一个提案，其中 n 为提案编号，v 为提议值。

假设客户端 1 的提案编号为 1，客户端 2 的提案编号为 5，并假设节点 A、B 先收到来自客户端 1 的准备请求，节点 C 先收到来自客户端 2 的准备请求。

整个共识协商是分 2 个阶段进行的

### 1. 准备（Prepare）阶段

首先客户端 1、2 作为提议者，分别向所有接受者发送包含提案编号的准备请求：

![paxos1](/study/imgs/paxos1.png)

接着，当节点 A、B 收到提案编号为 1 的准备请求，节点 C 收到提案编号为 5 的准备请求后，将进行这样的处理：


![paxos2](/study/imgs/paxos2.png)


由于之前没有通过任何提案，所以节点 A、B 将返回一个 “尚无提案”的响应。也就是说节点 A 和 B 在告诉提议者，我之前没有通过任何提案呢，并承诺以后不再响应提案编号小于等于 1 的准备请求，不会通过编号小于 1 的提案。

节点 C 也是如此，它将返回一个 “尚无提案”的响应，并承诺以后不再响应提案编号小于等于 5 的准备请求，不会通过编号小于 5 的提案。


另外，当节点 A、B 收到提案编号为 5 的准备请求，和节点 C 收到提案编号为 1 的准备请求的时候，将进行这样的处理过程：

![paxos3](/study/imgs/paxos3.png)


当节点 A、B 收到提案编号为 5 的准备请求的时候，因为提案编号 5 大于它们之前响应的准备请求的提案编号 1，而且两个节点都没有通过任何提案，所以它将返回一个 “尚无提案”的响应，并承诺以后不再响应提案编号小于等于 5 的准备请求，不会通过编号小于 5 的提案。


当节点 C 收到提案编号为 1 的准备请求的时候，由于提案编号 1 小于它之前响应的准备请求的提案编号 5，所以丢弃该准备请求，不做响应。


### 2. 接受（Accept）阶段

第二个阶段也就是接受阶段，首先客户端 1、2 在收到大多数节点的准备响应之后，会分别发送接受请求：
![paxos4](/study/imgs/paxos4.png)

当客户端 1 收到大多数的接受者（节点 A、B）的准备响应后，根据响应中提案编号最大的提案的值，设置接受请求中的值。因为该值在来自节点 A、B 的准备响应中都为空
（也就是图 5 中的“尚无提案”），所以就把自己的提议值 3 作为提案的值，发送接受
请求[1, 3]。

当客户端 2 收到大多数的接受者的准备响应后（节点 A、B 和节点 C），根据响应中提案编号最大的提案的值，来设置接受请求中的值。因为该值在来自节点 A、B、C 的准备响应中都为空（也就是图 5 和图 6 中的“尚无提案”），所以就把自己的提议值 7 作为提案的值，发送接受请求[5, 7]。


当三个节点收到 2 个客户端的接受请求时，会进行这样的处理：

![paxos5](/study/imgs/paxos5.png)

当节点 A、B、C 收到接受请求[1, 3]的时候，由于提案的提案编号 1 小于三个节点承诺能通过的提案的最小提案编号 5，所以提案[1, 3]将被拒绝。

当节点 A、B、C 收到接受请求[5, 7]的时候，由于提案的提案编号 5 不小于三个节点承诺能通过的提案的最小提案编号 5，所以就通过提案[5, 7]，也就是接受了值 7，三个节点就 X 值为 7 达成了共识。

如果集群中有学习者，当接受者通过了一个提案时，就通知给所有的学习者。当学习者发现大多数的接受者都通过了某个提案，那么它也通过该提案，接受该提案的值。

通过上面的演示过程，你可以看到，最终各节点就 X 的值达成了共识。那么在这里我还想强调一下，Basic Paxos 的容错能力，源自“大多数”的约定，你可以这么理解：当少于一
半的节点出现故障的时候，共识协商仍然在正常工作。


最终各节点就 X 的值达成了共识。那么在这里我还想强调一下，Basic Paxos 的容错能力，源自“大多数”的约定，你可以这么理解：当少于一
半的节点出现故障的时候，共识协商仍然在正常工作。



## 参考资料

- [分布式共识算法之Paxos详解](https://zhuanlan.zhihu.com/p/489796705)
