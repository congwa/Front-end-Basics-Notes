# 常见限流算法

在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可**防止DoS攻击和限制Web爬虫**

限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。限流会导致部分用户请求处理不及时或者被拒，这就影响了用户体验。


## 固定窗口限流算法

首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。

- 当次数少于限流阀值，就允许访问，并且计数器+1
- 当次数大于限流阀值，就拒绝访问。
- 当前的时间窗口过去之后，计数器清零。

```js

function fixedWindowLimiting(limitThreshold, windowSize) {

  // 定义计数器和最后一次记录时间
  let counter = 0;
  let lastRecordTime = Date.now();

  // 返回一个处理请求的函数
  return function handleRequest() {
    // 获取当前时间
    const now = Date.now();

    // 判断当前时间是否已经超出了时间窗口，如果是则重置计数器和最后一次记录时间
    if (now - lastRecordTime > windowSize) {
      counter = 0;
      lastRecordTime = now;
    }

    // 判断计数器是否已经达到限流阀值，如果是则拒绝请求
    if (counter >= limitThreshold) {
      console.log('请求被拒绝');
      return;
    }

    // 允许请求，并将计数器加1
    console.log('请求被允许');
    counter++;
  };
}

// 使用封装的函数创建一个限流函数
const handleRequest = fixedWindowLimiting(3, 1000);

// 测试代码，模拟连续请求
handleRequest(); // 请求被允许
handleRequest(); // 请求被允许
handleRequest(); // 请求被允许
handleRequest(); // 请求被拒绝
setTimeout(handleRequest, 1500); // 请求被允许
```

这种算法有一个很明显的**临界问题**:

假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经超过单位时间1s不超过5阀值的定义啦。定义区间漏洞



## 滑动窗口限流算法

滑动窗口限流解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期

假设单位时间还是1s，滑动窗口算法把它划分为5个小周期，也就是滑动窗口（单位时间）被划分为5个小格子。每格表示0.2s。每过0.2s，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是0.83s到达的，0.8~1.0s对应的计数器就会加1

滑动窗口是如何解决临界问题的？

假设我们1s内的限流阀值还是5个请求，0.8~1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2~1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝啦。

当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

```js
function slidingWindow(thresholdPerMin, subCycle) {
  let counters = new Map(); // 使用Map作为计数器

  return function () {
    let currentWindowTime = Math.floor(Date.now() / 1000 / subCycle) * subCycle; // 获取当前时间在哪个小周期窗口
    let currentWindowCount = counters.get(currentWindowTime) || 0; // 获取当前窗口的计数，初始值为0

    // 判断当前窗口是否超过限流阈值
    if (currentWindowCount >= thresholdPerMin) {
      return false;
    }

    // 更新当前窗口的计数器
    counters.set(currentWindowTime, currentWindowCount + 1);

    // 将历史窗口的计数器删除，只保留最近的6个小周期（即1分钟）
    let startTime = currentWindowTime - subCycle * (60 / subCycle - 1);
    for (let key of counters.keys()) {
      if (key < startTime) {
        counters.delete(key);
      }
    }

    return true;
  };
}

const tryAcquire = slidingWindow(5, 10); // 限制每分钟接受5个请求，每个小周期为10秒

// 测试
for (let i = 1; i <= 10; i++) {
  setTimeout(() => {
    if (tryAcquire()) {
      console.log(`请求${i}通过`);
    } else {
      console.log(`请求${i}被限流`);
    }
  }, i * 1000);
}
```

## 漏桶算法




## 令牌桶算法



## 参考

[面试必备：4种经典限流算法讲解](https://mp.weixin.qq.com/s/tlaL0ByrWVQ0qiDssSPWnQ)