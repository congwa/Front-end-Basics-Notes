# 常见名词记录

## 哨兵变量

用于检查次数的变量

## 自旋

自旋，即不断重试以下操作 

1. 读取新值 
2. 再次比较是否一致，如果一致则写入 
3. 不一致则再次重试整个操作

## 自旋锁

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。

## 原子操作

原子操作就是不可中断的操作，这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界是看不到原子操作的中间状态。

## 原子性

所谓原子性是指一段代码在执行过程中的「中间过程」中其他线程是感知不到的，对外表现的效果就是要么执行完了，要么没有执行。

在go语言中，atomic包提供了一组函数接口可以保证我们操作的原子性。

## 雪崩

所谓雪崩问题,就是在高访问量、大并发量的情况下缓存失效的情景,此时大量的请求同时涌人数据库中,数据车无法同时承受如此大的查询请求,进而往前影响到网站整体的响应速度。

> 在《深入浅出node.js》给出使用事件队列解决雪崩问题的解决方案。


## 轮叫调度

在node的多进程监听相同端口，默认处理负载均衡的时候是抢占的制度的，抢占就代表着繁忙的时候不去抢占，但是在node中繁忙的可以是io繁忙和cpu繁忙，影响抢占的是cpu繁忙度(不同的业务场景中可能是I/O繁忙,CPU空闲，导致某个请求抢到较多的请求，形成负载不均衡)，为了达到更高的利用率，主进程接受链接，将其依次分发给工作进程。
> 以上来源《深入浅出node.js》


## CAS (Compare And Swap)

![cas](/study/imgs/cas.webp)

比较 和 交换 两个操作。  如果先比较，如果一致,则交换。由于每次只是检测是否一致，是否有冲突，所以这是一种基于冲突检测的机制。

注意：CAS是一种思想，既可以在硬件层实现（如CMPXCHG指令），也可以在应用上层实现（如乐观锁）

在比较中，如果发现不一样，一般的补偿机制是自旋，即不断重试以下操作 
1. 读取新值 
2. 再次比较是否一致，如果一致则写入
3. 不一致则再次重试整个操作

目前基于CAS实现的技术非常多，常见的有如下几种
- 乐观锁
- MVCC


CAS的缺点： cpu开销大，ABA问题
CAS的优点： 性能明显高于锁

## CAP

在设计一个大规模可扩放的网络服务时候会遇到三个特性：一致性（consistency）、可用性（Availability）、分区容错（partition-tolerance）都需要的情景.

​CAP定律说的是在一个分布式计算机系统中，一致性，可用性和分区容错性这三种保证无法同时得到满足，最多满足两个

![cap](/study/imgs/cap.webp)

如上图，CAP的三种特性只能同时满足两个。而且在不同的两两组合，也有一些成熟的分布式产品。

接下来，我们来介绍一下CAP的三种特性，我们采用一个应用场景来分析CAP中的每个特点的含义。

![cap_demo](/study/imgs/cap_web.webp)

该场景整体分为5个流程：

1. 流程一、客户端发送请求(如:添加订单、修改订单、删除订单)
2. 流程二、Web业务层处理业务，并修改存储成数据信息
3. 流程三、存储层内部Master与Backup的数据同步
4. 流程四、Web业务层从存储层取出数据
5. 流程五、Web业务层返回数据给客户端

### (1) 一致性Consistency

一旦数据更新完成并成功返回客户端后，那么分布式系统中所有节点在同一时间的数据完全一致。

> 在CAP的一致性中还包括强一致性、弱一致性、最终一致性等级别

一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。

一致性实现目标：

- Web业务层向主Master写数据库成功，从Backup读数据也成功。
  ![c1](/study/imgs/c1.webp)
- Web业务层向主Master读数据库失败，从Backup读数据也失败。
  ![c2](/study/imgs/c2.webp)
  必要实现流程：
  ![c3](/study/imgs/c3.webp)
写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。

分布式一致性特点：

1. 由于存在数据同步的过程，写操作的响应会有一定的延迟。
2. 为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。
3. 如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。


### 可用性(Availability)

服务一直可用，而且**是正常响应时间**。

可用性实现目标：

- 当Master正在被更新，Backup数据库接收到数据查询的请求则立即能够响应数据查询结果。
- backup数据库不允许出现响应超时或响应错误。

![a1](/study/imgs/a1.webp)

必要实现流程：

![a2](/study/imgs/a2.webp)

1. 写入Master主数据库后要将数据同步到从数据库。
2. 由于要保证Backup从数据库的可用性，不可将Backup从数据库中的资源进行锁定。
3. 即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据/或者默认数据，但不能返回错误或响应超时。

分布式可用性特点：
所有请求都有响应，且不会出现响应超时或响应错误。

### 分区容错性(Partition tolerance)


分布式系统中，尽管部分节点出现任何消息丢失或者故障，系统应继续运行。

通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务。


分区容错性实现目标：

- 主数据库向从数据库同步数据失败不影响读写操作。
  ![p1](/study/imgs/p1.webp)
- 其一个结点挂掉不影响另一个结点对外提供服务。
  ![p2](/study/imgs/p2.webp)

必要实现流程：

1. 尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现松耦合。
2. 添加Backup从数据库结点，其中一个Backup从结点挂掉其它Backup从结点提供服务。

![p3](/study/imgs/p3.webp)

分区容错性特点：

分区容忍性分是布式系统具备的基本能力。 (在分布式系统中，既然P是必须要满足的基本能力，那么只能在A和C之中按照业务类型放弃一个)





## 脑裂

脑裂，也就是说，某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的脑裂。


