<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.4"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"常见线程池模型","children":[{"type":"heading","depth":1,"payload":{"lines":[2,3]},"content":"为什么需要线程池","children":[{"type":"heading","depth":2,"payload":{"lines":[8,9]},"content":"线程池好处"}]},{"type":"heading","depth":1,"payload":{"lines":[16,17]},"content":"线程池的组成","children":[{"type":"bullet_list","depth":2,"payload":{"lines":[18,25]},"content":"","children":[{"type":"list_item","depth":3,"payload":{"lines":[18,19]},"content":"corePoolSize:核心线程数,常驻线程池的线程数量"},{"type":"list_item","depth":3,"payload":{"lines":[19,20]},"content":"maxPoolSize:线程池最大线程数量,当任务特别多的时候,corePoolSize线程数量无法满足需求的时候,就会继续创建线程,最大不超过maxPoolSize."},{"type":"list_item","depth":3,"payload":{"lines":[20,21]},"content":"KeepAliveTime+时间单位:空闲线程的存活时间"},{"type":"list_item","depth":3,"payload":{"lines":[21,22]},"content":"ThreadFactory:线程工厂,用来创建线程"},{"type":"list_item","depth":3,"payload":{"lines":[22,23]},"content":"WorkQueue:任务队列,用来存放任务"},{"type":"list_item","depth":3,"payload":{"lines":[23,24]},"content":"Handler:处理被拒绝的策略"}]},{"type":"ordered_list","depth":2,"payload":{"lines":[28,51],"startIndex":1},"content":"","children":[{"type":"list_item","depth":3,"payload":{"lines":[28,29],"index":1},"content":"1. 当提交任务后,,线程池首先会检查当前线程数,如果当前线程数小于核心线程数,则新建线程并执行任务."},{"type":"list_item","depth":3,"payload":{"lines":[29,30],"index":2},"content":"2. 随着任务不断增加,线程数达到了核心线程数的数量,此时任务依然在增加,那么新来的任务将会放到workQueue等待队列中,等核心线程执行完任务后重新从队列中提取出等待被执行的任务"},{"type":"list_item","depth":3,"payload":{"lines":[30,31],"index":3},"content":"3. 如果已经达到了核心线程数,且任务队列也满了,则线程池就会继续创建线程来执行任务,如果任务不断提交,线程池会持续创建线程直到达到maximumPoolSize最大线程数,当达到了最大线程数后,任务仍不断提交,那么此时就超过了线程池的最大处理能力,这个时候线程池就会拒绝处理这些任务,处理策略就是handler."},{"type":"list_item","depth":3,"payload":{"lines":[31,33],"index":4},"content":"4. corePoolSize和maximumPoolSize：<br>\n从上面的流程中可以看出,线程池初始化时,默认的线程数是0,当有任务提交后,开始创建核心线程去执行任务,当线程数达到核心线程数时且任务队列满了后,开始创建非核心线程执行任务,最大可以达到maximumPoolSize,如果这是任务不提交了,线程开始空闲,那么默认情况下大于corePoolSize的线程在超过设置的KeepAliveTime时间后会被合理的收回,所以默认情况下,线程池中的线程数量处于corePoolSize和maximumPoolSize之间."},{"type":"list_item","depth":3,"payload":{"lines":[33,35],"index":5},"content":"5. KeepAliveTime+时间单位：<br>\n默认情况下,当线程池中的数量多于核心线程数时,而此时有没有任务可做,那么线程池就会检测线程的KeepAliveTime,如果超过了规定的时间,则无事可做的线程就会被销毁,以便减少内存的占用和资源消耗,如果后期任务又多了起来,则线程池根据规则重新创建线程,通过这个可伸缩的功能,可以实现对资源的合理使用,我们可以通过setKeepAliveTime设置keepAliveTime时间,还可以通过设置allowCoreThreadTimeOut参数,这个参数默认是false,如果设置成true,则会给核心线程数设置超时等待时间, 如果超过时间了核心线程就会销毁."},{"type":"list_item","depth":3,"payload":{"lines":[35,37],"index":6},"content":"6. ThreadFactory：<br>\nThreadFactory是一个线程工厂,负责生产线程去执行任务,默认的线程工厂,创建的线程会在同一个线程组,并且拥有一样的优先级,且都不是守护线程,我们也可自定义线程工厂,以便给线程自定义名字."},{"type":"list_item","depth":3,"payload":{"lines":[37,44],"index":7},"content":"7. workQueue：<br>\n阻塞队列,用来存放任务,我们主要分析一下5种阻塞队列:<br>\n- ArrayBlockingQueue是基于数组的有界阻塞队列,按照FIFO排序,新来的队列会放到队列尾部,有界的数组可以防止资源被耗尽问题,当线程达到了核心线程数,再来任务的时候就放到队列的尾部,当队列满了的时候,则继续创建非核心线程,如果线程数量达到了maxPoolSize,则会执行拒绝策略.<br>\n- LinkedBlockingQueue是基于链表的无界阻塞队列(最大容量是Integer.MAX),按照FIFO排序,当线程池中线程数量达到核心线程数时,继续来了新任务会一直存放到队列中,而不会创建新线程.因此使用此队列时,maxPoolSize是不起做的<br>\n- SynchronousQueue是一个不缓存任务的阻塞队列,当来了新任务的时候,不会缓存到队列中,而是直接被线程执行该任务,如果没有核心线程可用就创建新线程去执行任务,达到了maxPoolSize时,就执行拒绝策略.<br>\n- PriorityBlockingQueue是一个具有优先级的无界阻塞队列,优先级通过参数Comparator实现<br>\n- DelayedWorkQueu队列的特点是内部的任务并不是按照放入的时间排序,而是会按照延迟的时间长短对任务进行排序,内部采用的是“堆”数据结构.而且它也是一个无界队列."},{"type":"list_item","depth":3,"payload":{"lines":[44,51],"index":8},"content":"8. handler：<br>\n拒绝策略是当线程池中任务达到了队列最大容量,且线程数量也达到了最大maxPoolSize的时候,如果继续有新任务来了,则执行这个拒绝策略来处理新来的任务,jdk提供4种拒绝策略,它们都实现了RejectedExecutionHandler接口:<br>\n- CallRunsPolicy:该策略下,在调用者线程中直接执行被拒绝任务的run方法,就是谁提交的任务,谁负责执行任务,这样任务不会丢失,而且执行任务比较费时,那么提交任务的线程也会被占用,就可以减缓任务提交速度.<br>\n- AbortPolicy:该策略下,直接抛弃任务,并抛RejectedExecutionException异常.<br>\n- DiscardPolicy:该策略下,直接抛弃任务.<br>\n- DiscardOldestPolicy:该策略下,抛弃最早进入队列中的那个任务,然后尝试把这次拒绝的任务放入队列.<br>\n除此之外，我们还可以通过实现 RejectedExecutionHandler 接口来实现自己的拒绝策略,在接口中我们需要实现rejectedExecution方法,在rejectedExecution方法中,执行例如暂存任务、重新执行等自定义拒绝策略."}]}]},{"type":"heading","depth":1,"payload":{"lines":[53,54]},"content":"常见线程池","children":[{"type":"heading","depth":2,"payload":{"lines":[55,56]},"content":"1. FixedThreadPool-固定线程数"},{"type":"heading","depth":2,"payload":{"lines":[59,60]},"content":"2. CachedThreadPool- 缓存线程池"},{"type":"heading","depth":2,"payload":{"lines":[63,64]},"content":"3. ScheduledThreadPool-周期性执行任务","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[67,71]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[67,68]},"content":"schedule,通过延迟指定时间后执行一次任务,代码中设置的是10秒,所以10秒后执行一次任务就结束."},{"type":"list_item","depth":4,"payload":{"lines":[68,69]},"content":"scheduleAtFixedRate,通过名称我们可以看出,第二种是以固定频率去执行任务,它的第二个参数initialDelay表示第一次延迟时间,第三个参数period表示周期,总体按照上面的代码意思就是,第一次延迟10秒后执行任务,然后,每次延迟10秒执行一次任务."},{"type":"list_item","depth":4,"payload":{"lines":[69,70]},"content":"scheduleWithFixeddelay这种与第二种方法类似,也是周期执行任务,不同的是对周期的定义,之前的scheduleAtFixedRate是以任务的开始时间为起点开始计时,时间到了就开始执行第二次任务,而不管任务需要多久执行,而scheduleWithFixeddelay是以任务结束的时间作为下一次循环开始的时间起点."}]},{"type":"fence","depth":3,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ScheduledExecutorService</span> service <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newScheduledThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nservice<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nservice<span class=\"token punctuation\">.</span><span class=\"token function\">scheduleAtFixedRate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nservice<span class=\"token punctuation\">.</span><span class=\"token function\">scheduleWithFixedDelay</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SECONDS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"}]},{"type":"heading","depth":2,"payload":{"lines":[79,80]},"content":"4. SingleThreadExecutor-只有一个线程去执行任务"},{"type":"heading","depth":2,"payload":{"lines":[83,84]},"content":"5. SingleThreadScheduleExecutor- 只有一个线程，只是将核心线程数设置为了1"},{"type":"heading","depth":2,"payload":{"lines":[86,87]},"content":"6. ForkJoinPool - 分解成多个子任务，并行计算","children":[{"type":"heading","depth":3,"payload":{"lines":[90,91]},"content":"第一点是fork和join:"},{"type":"heading","depth":3,"payload":{"lines":[94,95]},"content":"第二点是内部结构不同"}]}]},{"type":"heading","depth":1,"payload":{"lines":[109,110]},"content":"如何自定义合适的线程池","children":[{"type":"heading","depth":2,"payload":{"lines":[113,114]},"content":"CPU密集型任务"},{"type":"heading","depth":2,"payload":{"lines":[117,118]},"content":"耗时IO任务"},{"type":"heading","depth":2,"payload":{"lines":[123,124]},"content":"总结","children":[{"type":"list_item","depth":3,"payload":{"lines":[125,126]},"content":"线程的平均工作时间所占比例越高,就需要越少线程."},{"type":"list_item","depth":3,"payload":{"lines":[126,127]},"content":"线程的平均等待时间所占比例越高,就需要越多的线程"},{"type":"list_item","depth":3,"payload":{"lines":[127,128]},"content":"针对不同的程序,进行对应的实际测试就可以获得更合适的选择."}]}]},{"type":"heading","depth":1,"payload":{"lines":[129,130]},"content":"如何正确关闭线程池","children":[{"type":"list_item","depth":2,"payload":{"lines":[133,134]},"content":"void shutdown()","children":[{"type":"list_item","depth":3,"payload":{"lines":[134,135]},"content":"等待线程池中正在执行的任务和队列中等待的任务执行完毕。这个方法不会立即关闭线程池，而是允许已经提交的任务继续执行"}]},{"type":"list_item","depth":2,"payload":{"lines":[135,136]},"content":"boolean isShutdown()","children":[{"type":"list_item","depth":3,"payload":{"lines":[136,137]},"content":"检查线程池是否已经开始关闭。如果返回值为 true，表示线程池已经开始关闭但还未彻底关闭，可能仍有任务在执行或队列中等待执行"}]},{"type":"list_item","depth":2,"payload":{"lines":[137,138]},"content":"boolean isTerminated()","children":[{"type":"list_item","depth":3,"payload":{"lines":[138,139]},"content":"方法判断线程池是否已经彻底关闭。如果返回值为 true，表示线程池已经关闭且所有任务已经执行完毕"}]},{"type":"list_item","depth":2,"payload":{"lines":[139,140]},"content":"boolean awaitTermination(long timeout,TimeUnit unit)，throws IntereuptedException","children":[{"type":"list_item","depth":3,"payload":{"lines":[140,141]},"content":"等待一段指定的时间，如果在等待时间内线程池已关闭且所有任务都执行完毕，则返回 true；如果等待时间超时或者等待期间被中断，则返回 false。"}]},{"type":"list_item","depth":2,"payload":{"lines":[141,142]},"content":"List shutdownNow()","children":[{"type":"list_item","depth":3,"payload":{"lines":[142,143]},"content":"如果需要立即关闭线程池并且停止所有任务的执行，可以调用 shutdownNow() 方法。该方法会给所有线程发送中断信号并将等待执行的任务转移到一个列表中返回"}]}]},{"type":"heading","depth":1,"payload":{"lines":[145,146]},"content":"线程池复用原理","children":[{"type":"fence","depth":2,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span> command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token comment\">//如果传入的Runnable的空，就抛出异常</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>command <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token doc-comment comment\">/**\n    * 当前线程数是否小于核心线程数，如果小于核心线程数就调用 addWorker() \n    * 方法增加一个 Worker，这里的 Worker 就可以理解为一个线程\n    */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">int</span> recheck <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span> <span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n            <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n            <span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"}]}]},{})</script>
</body>
</html>
