# https

1. 第一步：客户端发送TLS版本，加密套件列表，client_random（用户端生成的随机数）给服务端。
2. 第二步：服务端发送加密套件（筛选好的双方都支持的），带公钥的证书和server_random（服务端生成的随机数）给客户端。
3. 第三步：证书验证通过，客户端通过加密套件和RSA算法生成pre_random（一个随机数）。通过公钥加密pre_random，客户端发送encrypted_pre_random（加密后的随机数）给服务端。
4. 最终：服务端通过私钥从encrypted_pre_random解密获得pre_random。
此时服务端和客户端都有client_random，server_random, pre_random，再用确认的加密套件混合，生成master_key作为会话秘钥。

## rsa

1. 浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。
2. 服务器接收到，立即返回 server_random，确认好双方都支持的加密套件以及数字证书 (证书中附带公钥 Public key certificate)。
3. 浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
4. 服务器用私钥解密这个被加密后的 pre_random，参考 “非对称加密”。

![https-rsa](/study/imgs/https-rsa.awebp)

## dh

```diff
1.浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。

// RSA
-2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件
-以及数字证书 (证书中附带公钥)。
// DH
+2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件
+以及数字证书 (证书中附带公钥)。
+同时服务器利用私钥将 client_random，server_random，server_params 签名，
+生成服务器签名。然后将签名和 server_params 也发送给客户端。 
+这里的 server_params 为 DH 算法所需参数。

// RSA
-3.浏览器接收，先验证数字证书。
-若通过，接着使用加密套件的密钥协商算法 RSA 算法
-生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
// DH
+3.浏览器接收，先验证数字证书和 _签名_。
+若通过，将 client_params 传递给服务器。
+这里的 client_params 为 DH 算法所需参数。

-4.服务器用私钥解密这个被加密后的 pre_random，参考 “非对称加密”。
+4.现在客户端和服务器都有 client_params、server_params 两个参数，
+因 ECDHE 计算基于 “椭圆曲线离散对数”，通过这两个 DH 参数就能计算出 pre_random。

```

![https-dh](/study/imgs/https-dh.awebp)

DH 握手前向安全性


## tsl 1.3

TLS1.3 废除了原有的部分不安全的加密算法，其中甚至包括 RSA 算法。

RSA 算法的废除不仅因为已经有大能将其破解，同时还缺少 前向安全性。何为前向安全？即能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。


![tsl1.3](/study/imgs/tsl1.3.awebp)

```diff
// 原 DH 握手
-1.浏览器向服务器发送 client_random，TLS 版本和供筛选的加密套件列表。
// TLS1.3 优化
+1.浏览器向服务器发送 client_params，client_random，TLS 版本和供筛选的加密套件列表。

// 原 DH 握手
-2...
// TLS1.3 优化
+2.服务器返回：server_random、server_params、TLS 版本、确定的加密套件方法以及证书。
+浏览器接收，先验证数字证书和签名。
+现在双方都有 client_params、server_params，可以根据 ECDHE 计算出 pre_random 了。

```


## 混合加密

在通信刚开始的时候使用 非对称加密 算法，解决密钥交换的问题。 但是由于非对称加密的性能差，后续全部使用对称加密进行通讯。

## 数字证书

1. 服务器向浏览器证明自己的身份，毕竟秘钥、甚至服务器域名都是可以伪造的。
2. 把公钥传给浏览器。

证书本身是由权威、受信任的证书颁发机构 (CA) 授予的。

### 证书包含内容

HTTPS（Hypertext Transfer Protocol Secure）的证书是一种数字证书，用于在 HTTPS 连接中对网站进行身份验证和加密通信。它由可信的第三方机构，即证书颁发机构（Certificate Authority，CA）签发。

HTTPS 证书包含以下信息：
1. 公钥和私钥：证书中包含一个公钥，用于加密通信，以及与之配对的私钥，用于解密数据。这对密钥是在生成证书时创建的，并且只有私钥持有者可以解密使用公钥加密的数据。
2. 网站信息：证书中包含了与网站相关的信息，如域名（Domain Name），组织名称（Organization Name），组织单位（Organization Unit），所在地（Location），以及有效期等。这些信息可用于验证网站的身份。
3. 数字签名：证书中还包含一个数字签名，用于验证证书的完整性和真实性。CA 使用自己的私钥对证书中的信息进行签名，其他人可以使用 CA 的公钥来验证签名。如果签名验证成功，则表示证书未被篡改并且确实由 CA 签发。
   
当用户访问一个使用 HTTPS 的网站时，客户端（例如浏览器）会检查网站的证书。客户端会验证证书链、验证签名、检查证书的有效期以及其他安全检查。如果验证通过，客户端会使用证书中的公钥与网站进行安全通信，加密和解密传输的数据。

通过使用 HTTPS 证书，网站可以提供加密保护，确保敏感信息在传输过程中不被窃听和篡改，并通过验证证书来建立对网站身份的信任。这对于保护用户隐私和防止恶意攻击至关重要。

> CA 在签发证书时使用其私钥对证书进行签名。私钥不会公开共享，只有 CA 可以访问私钥来执行签名操作。通过保护私钥的安全，确保私钥仅限于 CA 并且受到严格的控制，可以防止恶意实体伪造证书、篡改证书或其他未经授权的活动。
> 用户的计算机可以使用特定的软件库或驱动程序来与 HSM 进行交互，从而利用HSM提供的安全功能。这些软件库或驱动程序允许用户进行诸如生成密钥、签名数据、加密解密等安全操作，并将这些操作请求发送给 HSM 进行处理。

### 在客户端验证 CA 签名是否被篡改通常遵循以下步骤

在客户端验证 CA 签名是否被篡改通常遵循以下步骤：

1. 获取证书：客户端从服务器或其他来源获取证书，其中包含 CA 的签名。
2. 验证证书链：客户端首先验证证书链中的每个证书的有效性。首先，客户端会检查证书链中的根证书是否受信任并具有有效的身份验证。然后，逐级验证证书链中的每个证书，确保每个证书都以前一个证书的私钥进行签名，并检查证书中的数字签名是否有效。
3. 检查证书签名：当客户端验证证书链时，它也会验证 CA 的签名。客户端使用根证书中的公钥来解密证书中的签名，并使用相同的哈希算法重新计算哈希值。然后，它将计算得到的哈希值与证书中的签名验证是否匹配。如果两者一致，那么证书的签名就是有效的，没有被篡改。
4. 证书吊销检查：客户端还可以检查证书吊销列表（Certificate Revocation List，CRL）或在线证书验证协议（Online Certificate Status Protocol，OCSP）等，以确定证书是否被吊销。
   
通过使用受信任的根证书进行签名验证，客户端可以确信证书的完整性和真实性，从而建立起安全信任关系。



## 个人理解的特点

1. 申请的证书的时候，返回 证书(签名)、公钥、私钥
2. 证书由服务器下发到客户端，客户端的通过ca认证证书签名的有效性
3. 同时，服务器下发公钥，用于随机数加密，方便在回传数据到服务端
4. 服务端用私钥进行，解密。
5. 通过以上步骤之后，证书和签名验证来源，然后通过信息交换重新约定一个临时的对称加密的密钥，之后的通讯使用此密钥


## 参考资料

- [TLS 详解握手流程](https://juejin.cn/post/6895624327896432654)
- 在《深入浅出node.js》有一篇https的实现